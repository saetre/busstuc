%% FILE lex.pl
%% SYSTEM TUC
%% AUTHOR T.Amble
%% CREATED TA-931217
%% REVISED TA-010720


%% Transforms each word into a list of alternatives.



xcomposite(A,B,C):-composite(A,B,C). % busdat
xcomposite(A,B,C):-
    tram_mod(Tram),
    Tram:composite_stat(A,B,C).



xcomposite_stat(A,B,C):-composite_stat(A,B,C).
xcomposite_stat(A,B,C):-
    tram_mod(Tram),
    Tram:composite_stat(A,B,C). %% TA-010720



synword(X,Y):-dict_module(L),L:synwordx(X,Y). %% TA-010718

synword(X,Y):-synplace(X,Y). %% place names, language independent %% busdat.pl


synword(X,Y):-synbus(X,Y).   %% busdat.pl


% % % % % % % % % % % % % % % % % % % % % % % % % % 

%%%%%% The coding conventions %%%%%%%%%%%%%%%%%%%%%

%  w(<word>,List of Interpretations)
%
%       Interpretation
%                                             
%       noun(root,{sin,plu},{best,u},{gen,n})   best bestemt form , u ubest
%       name(root,{unknown,gen,n},{Class,0,unkn}) 
%       verb(root,{pres,past,imp},{fin,part})   {sin,plu} is of no consequence
%       adj(root,{ind,comp,sup})
%       prep(word)
%       nb(numeral,{ind,ord})
%       quote(text)
%       [word]                                  all others words 
%
%
% Underscore variables _  are used for
%
%       dont know   in the dictionary and
%       dont care   in the grammar
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%  LEXICAL ANALYSER %%%%%%%%%%%

% Flexible Bilingual version
%  analyse the input for selection of most probable language,
%  then answer in the same language

lexproc3(L1,AssumedLanguage,L3):- %% TA-001108
    language  =: AssumedLanguage,
    \+ value(duallangflag,true),  %% without duallangflag, only 1 language
    !,                            %% was test  value(textflag,true) %% TA-001119
    lexproc2(L1,L3,_Nunks).


lexproc3(L1,AssumedLanguage,L3):- 
    language  =: OldLanguage,


    lexproc2(L1,L2Old,NunksOld),
    !,
(    NunksOld = 0 -> 
        (AssumedLanguage = OldLanguage,
         L3 = L2Old)
;

(    the_other_language(OldLanguage,NewLanguage),
    language := NewLanguage,
    lexproc2(L1,L2New,NunksNew),
    !,
    language := OldLanguage, % ad hoc, for safety

    decide_language(NunksOld,NunksNew,OldLanguage,NewLanguage,AssumedLanguage),

    (AssumedLanguage = OldLanguage -> L3 = L2Old;
                                      L3 = L2New)
)).


the_other_language(english,norsk).
the_other_language(norsk,english).



decide_language(NuOld,NuNew,_Old,New,New):- 
    NuNew < NuOld,  % there are fewer unknowns in the new language 
    !.

decide_language(_NuOld,_NuNew,Old,_New,Old).


lexproc2(L1,L3,Nunks):-
    lexproc(L1,L3),
    unknown_words(strict,L3,Unknowns), %% To decide language, 
                                       %% neglect misspelled part_names
    length(Unknowns,Nunks).


lexproc(L1,L3):-
    lexps(L1,L2),
    remove_noise(L2,L3),
    !. 


lexps([],[]).
lexps([X|Y],[XL|YL]):-
    lcodes(X,XL),
    lexps(Y,YL).

lcodes(N,w(N,S2)):-
    set_of(N1,lcode1(N,N1),S),
    handle_unknown(N,S,S1),
    traceprint(4,handle_unknown(N,S,S1)), %% trace >4 -> write unknown list %% TA-010327
    squirtsurplus(N,S1,S2).

  
%% Levange = leangen/levanger Different names ==> just unknown
%% gårn = gran/gård  Different partnames, no mess
 
squirtsurplus(Twang,[],[name(Twang,unknown,unk)]):-!.


/* TA-010603  Made for the Levange Syndrome:

    Levange -> Levanger/  Leangen

Levanger is preferred because is a missing character error,
while Leangen is a non neighbour character swap.

Amblehash makes no preference

However, this is an anomaly, and is rectified by a directed synonym


squirtsurplus(Levange,Set,Residue):-  %% TA-010521
    set_of(Name,(member(name(Name,_,C),Set),C \==0,C\=street,\+ okdup(Name)) ,Names),
    length(Names,N),

    (N > 1 -> Residue = [name(Levange,unknown,unkn)];
              Residue = Set).
*/

squirtsurplus(_,S,S). % No unknowns



handle_unknown(N,Taglist,Names):-  %% Only called if NO Tags (feature)

    (  Taglist \== [] -> Names=Taglist; %%  TA-010528

    set_of(name(X,Gen,Class), 
           believed_name2(N,X,Gen,Class,_U), 
           Names)
    ).


%% NB   known_name has failed


%%  spellstreetflag is OBSOLOLETE  %% TA-010627
%% believed_name2(N,N,unknown,unkn,0):-   %% in addition
%%    true. %% \+    value(spellstreetflag,true).


believed_name2(A,B,C,D,E):-
    believed_name(A,B,C,D,E),
    \+ unwanted_place(B).          %% TA-010504


believed_name(N,X,n,Class,1):-    %% 1 = spellcheck
    value(spellcheck,1), 
    \+ unwanted_place(N),         % by decree 
    lextoresearch(N,Z),
    member(X1,Z),
    moshe_prepare(X1,X),
    moshe_class(X,Class). 


% Utility ?
numberalfa(TenA,Ten):- %% TA-010504
    name(TenA,List),
    append(Front,[Last],List),
    Front \== [],
    alphachar(Last),
    alldigits(Front),
    name(Ten,Front).


alldigits([]):-!.
alldigits([D|E]):-
    digch09(D),
    alldigits(E).


digch09(D):-  
    D >= 48, % 0
    D =< 57. % 9

alphachar(D):- 
    D >= 97,   % a
    D =< 122.  % z
    

% % % % % % % % %
 
target_name(X):-            % Candidate for auxillary table
    known_name(X),          % Contains duplicates !!!
    \+ irrelevant_name(X). 


irrelevant_name(X):-     %% DONT spellcheck towards these names !
    bus(X);
    unproperstation1(X); %% DONT spellcheck to spurious names ! 
    unwanted_place(X); 
    X isa man; 
    X isa woman.         %%
%   ....                 %% extendable

unproperstation1(X):- 
    unproperstation(X), %% no bus passes
    \+ neighbourhood(X).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%% REMOVE NOISE FROM INPUT %%%%%%%%%%%%%%%%%%%
%%                                                       %
%%   All '.','!','?' except the last is removed as noise %




remove_noise([W|Y],Z):- 
    noisy(W),
    !,
    remove_noise(Y,Z).

remove_noise([   w('(',_)   |Y],V):-     %% TA-001026
   value(noparentflag,true),  %% TA-001026 
   remove_inter_pares(Y,U),
   remove_noise(U,V).

remove_noise([X|Y],[X|Z]):-!,
    remove_noise(Y,Z).

remove_noise([],[]):-!.


remove_inter_pares([ w(')',_) |Y],Y):-!.
remove_inter_pares([_X|Y],Z):-!,
    remove_inter_pares(Y,Z).
remove_inter_pares([],[]).


noisy(w(_,[n_w])).   

noisy(w('.',_)):- value(nodotflag,true),!.  %% Experimental %% TA-010719
% noisy(w('.',_)):- \+ value(textflag,true).  %% TA-010719

% Saves a lot of misspellings with '.'
% ! and ? never noise



%% Individual Interpretations

synw0(X,Y):-synword(X,Y).
synw0(X,Y):- X=Y. 

lcode1('(',['(']):-value(noparentflag,true),!. 
lcode1(')',[')']):-value(noparentflag,true),!. 


lcode1(quote(X),quote(X)):-!.
lcode1('.',['.']):-!.  
lcode1(X,n_w):-
    dict_module(L),L:noisew(X), % incl. ( ) if not noparentflag
    !.

lcode1(TenA,nb(Ten,num)):- %% TA-010222
    value(spellcheck,1),
    \+ unwanted_place(TenA), %% e.g. 3T %% TA-010506
    numberalfa(TenA,Ten).  %% Only 1 letter is allowed ("5bussen")

lcode1(N0,N2):- 
    synw0(N0,N1),
    lcode2(N1,N2).

%% lcode2   

lcode2(X,Y):-morph_module(L),L:lcode2(X,Y).  %% 1

lcode2(N,nb(N,num)):-number(N).              %% 2

lcode2(M,nb(N,ord)):-ordinal2(M,_,N).        %% 3  

lcode2(Vei,name(street,n,0)):-            %% TA-010528
    streetsyn(Vei).       

lcode2(X,name(Y,n,Class)):-    % Known name or partname 
    \+ unwanted_place(X), 
    test_alias_name(X,Y),      %% TA-010117
    moshe_class(Y,Class), 
    Class \== number.  %% 5 is name of route, 5 is of class number  not qua name   

lcode2(JOHNS,name(JOHN,gen,Class)):- 
    ends_with(JOHNS,JOHN,s), 
    plausible_name(JOHN,_,Class).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

test_known_name(X,X):- %% munkegata -> neighbourhood
    once(plausible_name(X)). %% 

test_alias_name(X,Z):- %% TA-010523
    splitstreet0(X,Y,_),
    toredef(Y,street),
    append_atoms(Y,'_street',Z).

test_alias_name(X,Y):- %% TA-010327
    alias_name(X,Y),
    !.                %% for gods sake %% TA-001006
 
test_alias_name(X,X):- %% TA-010327
    known_name(X),
    !.                %% for gods sake %% TA-001006

% OOPS tambarskjelvesgate = tambarskjelvesstreet %% TA-010327
%    !. %% true.                %% for gods sake %% TA-001006
                                %% OOPS munkegata -> street ! (SIC) not place

known_name(X):- 
    plausible_name(X).        %% fact(X  isa _).

known_name(X):- 
    part_name(X). 

known_name(X):- 
    street_part_name(X). %% TA-001014 

known_name(X):-
     sameplace(X,_). 

known_name(X):-        %% low priority %% TA-010621
     tramstation(X).   %% Ad Hoc, tramstation is not a class !!!


% part_name(X):  X may be variable !!!

part_name(X):-  
    xcomposite_stat(First,Rest,_),  %% + tramstations
    ( X=First;
      member(X,Rest)
    ).

part_name(street). %% technical

% part names of roads are candidates for spell correction



part_name(X):-cmpl(X,_,_).
part_name(X):-cmpl(_,Y,_),atom(Y),X=Y.
part_name(X):-cmpl(_,[U|V],_),member(X,[U|V]). % expensive %
part_name(X):-cmpl(_,(U,V),_),roundmember(X,(U,V)). 


part_name(P):- %% TA-001108  
%%     value(wflag,true), %% temporary %% TA-001112
    lcompword(X,Y,_), %% New Predicate  dict_X.pl
    (P=X; member(P,Y)).

lcompword(X,Y,Z):- 
    dict_module(L),
    L:compword(X,Y,Z).


street_part_name(X):- %% NB X may be a variable
    composite_road(First,Rest,_), %% regcompstr.pl
    ( X=First;
      member(X,Rest)
    ).


%%%%%%%%%%%%%%%%%%%%%%%%%


plausible_atom(N):- 
    \+ kw(N).

plausible_name(N):- 
    !,
    plausible_name(N,_). %% TA-010605

plausible_name(N,C,C) :- %% TA-010605  Nostalgia 
    plausible_name(N,C).

plausible_name(X,C):-
    alias_name(X,Y),
    !,
    plausible_name(Y,C).

plausible_name(N,Class):- %% TA-010605
    value(error_phase,0),
    fact(N isa Class),
    atomic(N),
     \+ member(Class,[word,number,time]). 

plausible_name(N,Class):-
    value(error_phase,1),   %% first line 
    plausible_atom(N),      
    \+ instant(N,word),     
    fact(N isa Class).



unknown(W):- 
    \+ lcode2(W,_),
    \+ fact(W isa _),
    \+ member(W,['.',',','!']),
    \+ synword(_,W),
    \+ kw(W).  %% known words 

unknown_words(L,Z):- %% called from main.pl
    unknown_words(unstrict,L,Z).


unknown_words(Strict,L,Z):- 
     set_of(X,
             completely_unknown(Strict,X,L), %% AD HOC
            Z).        

% Write an unknown word warning unless the name is a misspelled fullname. 


completely_unknown(_strict,Nuss,L):-  %% TA-010528
     member(w(Nuss,NameSet),L), 
     member(name(Nuss,unknown,_),NameSet). 


only_part_name(Jakobsli):-  
    part_name(Jakobsli),        % a part_name can also be
    \+ station(Jakobsli),       % a station name
    \+ neighbourhood(Jakobsli). 

full_name(X):- 
     \+ only_part_name(X). 

%%%%%%%%%%%%%%%  LAYOUT %%%%%%%%%%%%%%%%%%

spread(L):-
    retractall(txt(_,_,_)),
    retractall(ctxt(_,_,_)),
    retractall(tempctxt(_,_,_)), %% TA-010327
    retractall(maxl(_)),
    cursor := 0,
    sprea(0,L),
    composal.

sprea(M,[X|Y]):-
    N is M+1,
    spreall(M,X,N), %% assert(txt(M,X,N)), 
    sprea(N,Y).

sprea(N,[]):- 
    assert(maxl(N)).


spreall(M,w(X,Z),N):- 
    for(member(U,Z),assert(txt(M,w(X,U),N))).



%%%%%%%%%%  Write a * at position in list

mix(C,L):- %% used by main.pl
    nl,nl,
    star(C), %% * if C=0   %% TA-001109
    mx(C,L),
    nl.

mx(C,[X|Y]):- !,
   D is C-1,
   outwx(X), 
   star(D), 
   mx(D,Y).

mx(_,[]):-nl.


star(0):- !,out('*').
star(_).

outwx(w(H,_)):-out(H).

%%%%%%%% Composite Lexical Analysis

%%% txt is initally only elementary steps
%   ctxt is temporarily the new texts
%   finally they are merged



composal:- 
     set_of((N,W,X),syntxt1(N,W,X,_),SYNTSET), 
     for(member((N,W1,X),SYNTSET),matchcomp(N,W1,X)), 

     for(ctxt(M1,W,N1),
        (moshe_class(W,Class), 
        assertnewa( txt(M1, w(W,name(W,n,Class)) ,N1)))
     ), 
 
     makecompwords, %% TA-001108
     cleantxt,
     emptyclosure,  
     !.

makecompwords :- %% Try every word
    for( txt(N1,w(Lap,_TAG),_), 
         matchcompword(N1,Lap)).

matchcompword(N1,Lap):-
    lcompword(Lap,TopComputer,Computer),
    N2 is N1+1,
    matchcompwrest(N2,TopComputer,N3),
    lcodew(Computer,WNoun), %% TA-010214
    assertnewa(txt(N1,w(Computer,WNoun),N3)). %% first, but only new %% TA-010214


matchcompwrest(N1,[Top|Computer],N3):-
    !,
    txt(N1,w(Top,_),N2),
    !,
    matchcompwrest(N2,Computer,N3).

matchcompwrest(N,[],N).

  
lcodew([],[]):-!.           %% TA-010214
lcodew(Computer,WNoun) :-   %%
    lcode1(Computer,WNoun). %% TA-010214  NB   downtown -> syn > hovedterminalen



% % % % % % % % % % % % % % % % % % % % 

emptyclosure :- %% remove all empty edges recursively
    movelasttofront,
    movefirsttoback.



%  move end towards back   

movelasttofront:-
   maxl(Maxl),

   for(txt(M2,w([],[]),Maxl), % dont remove this

       for(txt(M1,A,M2),
          (retract(txt(M1,A,M2)),
           asserta(txt(M1,A,Maxl))))). %% Should be fronted %% TA-010607


% move start  towards front

 movefirsttoback:-
    for(txt(M2,w([],[]),M3),
       (
        for(txt(M3,A,M4),
           (retract(txt(M3,A,M4)),
            asserta(txt(M2,A,M4)))) %% Should be fronted %% TA-010607
        ,
        retract(txt(M2,w([],[]),M3))
       )).



cleantxt:- 
     longestfirst,
     remove_partnames,
     remove_streetsurp.

remove_partnames:-
     retractall(txt(_M1,w(_W,name(_A,_B,0)),_N1)).


remove_streetsurp:- % Remove streetname (single) if also station/neighbourhood etc.
     for( (txt(M,w(A,name(_A1,_,street)),N),txt(M,w(A,name(_A2,_,K)),N), K \== street),
           retract(txt(M,w(A,name(_A1,_,street)),N))).


moshe_class2(Wgt,Wstreet,C):- 
    substreet0(Wgt,Wstreet),
    moshe_class(Wstreet,C). 

moshe_prepare(X-street,XYstreet):-!,
     append_atoms(X,'_street',XYstreet).   %% TA-010503

moshe_prepare(V-nil,V):-!.
moshe_prepare(V,V).


moshe_class(W,Stat):-fact(W isa Stat). %  Not Cut
moshe_class(W,0):- \+ fact(W isa _Stat). %% 0  partword



 %% AD HOC, when synonym complex names with same start
 %% longest name must occur first.
 %% otherwise, parser may cut (!)  after first match

longestfirst:- %% only names 
  for(    txt(M1,w(_Name1,name(_Name11,n,_C1)),M3),     % søndre gt
 (
    for( (txt(M1,w(Name2,name(Name21,n,C2)),M2), M3 > M2),
  retract(txt(M1,w(Name2,name(Name21,n,C2)),M2))) ,        % remove søndre

    for( (txt(M2,w(Name2,name(Name21,n,C3)),M3), M2 > M1), %  remove gt
  retract(txt(M2,w(Name2,name(Name21,n,C3)),M3)))
 )).


% % % % % %

matchcomp(N,_,Proff):-
    sameplace(Proff,Prof), 
    N1 is N+1,                           
    skip_dot(N1,N2),             %% TA-010720
    assertnewa(ctxt(N,Prof,N2)). %%
 
% Assume cmpl only used for > 1 words, otherwise redundant

matchcomp(N,_,Prof):-
    xcomposite(Prof,Brochsgate,Ident),
    N1 is N+1,
    matchrest(N1,Brochsgate,N2),
%     !,  % 1 match is nuff    Solbakken skole
    skip_dot(N2,N3),      %% TA-010720
    assertnewa(ctxt(N,Ident,N3)).   % locally in reverse order %% TA-010214 


% Roads

matchcomp(N,_,Prof):- % Prof Brochs gate 20
	xcomposite_road(Prof,Brochsgate,Ident), 
	N1 is N+1,
	matchrest(N1,Brochsgate,N2),
   anystreetnumber(N,Ident,N2). % ?



anystreetnumber(N0,Ident,N1) :-
   skip_dot(N1,N2),
   parsestreetnumber(N2,Num,N3),  %% TA-010207  yggdrasilvn. nr. 9
   Num < 500,  %%%%%%%%   Pragmatic test for street numbers/ not clock !!!
               %% TA-000928
        !,
	remember(txt(N0,w(Ident-Num,name(Ident-Num,n,street)),N3)). 
                           %% mellomveien 5(station) before mellomveien 5(street)
                           %% TA-001215

anystreetnumber(N1,Ident,N2) :-
   skip_dot(N2,N3),                 %% TA-010718
   assertstreetxt(N1,Ident,N3).     %% Last   


   
parsestreetnumber(N1,Num,N3) :-  %% TA-010718  yggdrasilvn .  nr. 9
    skip_nr(N1,N2),
    txt(N2,w(_N,nb(Num,num)),N3).

skip_nr(N2,N4):-  
    txt(N2,w(nr,_),N3),
    skip_dot(N3,N4),
    !.     %% TA-010207 
skip_nr(N2,N3):-  txt(N2,w(nummer,_),N3),!. %% TA-010305
skip_nr(N2,N2).

% . after street names may be abbrev.   gt.  %% TA-010718



skip_dot(N2,N3):-txt(N2, w('.',['.']), N3),!.
skip_dot(N2,N2).


assertstreetxt(N,Ident,N2):- 
    remember(txt(N, w(Ident,name(Ident,n,street)), N2)).   %% added after txt as final option  !!!


xcomposite_road(ProfY,Brochsgate,Ident):-
	composite_road(ProfY,Brochsgate,Ident).

xcomposite_road(Abels_gate,[],Abels_gate):-
	streetstat(Abels_gate,_,_,_,_).


matchrest(N,[X|Z],N2):-
    matchsyntxt(N,X,N1),
    matchrest(N1,Z,N2).
    
matchrest(N,[],N):-
    !. %% [] is an atom 
    
matchrest(N,X,N1):- %% X \= [] %%  allows cmpl(X,(Y,Z),W)
    atom(X),
    !,
    matchsyntxt(N,X,N1).

matchrest(N,(X,Z),N2):- 
    matchsyntxt(N,X,N1), 
    matchrest(N1,Z,N2).



syntxt1(N,Vei,Veg,N1):- % strict
    txt(N,Word,N1),
    (Word = w(Vei,name(Veg,n,_));
     Word = w(Vei,[Veg])).


syntxt(N,Veg,N1):- %%   liberal
    txt(N,Word,N1),
    (Word = w(Veg,_);
     Word = w(_Vei,[Veg]);
     Word = w(_Vei,name(Veg,n,_))).


matchsyntxt(N,street,N1):- %% TA-010528
    syntxt(N,Vei,N1),
    streetsyn(Vei).       

matchsyntxt(N,Veh,N1):- %% match lexicals with hash
     syntxt(N,Veg,N1),
     lextorehash0(Veh,Veg).  %% TA-010528


assertnewa(P):-P,!;
    asserta(P).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Spell correction 
%%
%% NOT ACTUALLY REQUIRED UNDER AMBLEHASHING

% Compare two strings for an  n error deviation.

spc(A,B):-
    spellcheck(A,B,F),
    write(F),nl.


% spellcheck(Input1,Candidate,Distance).

/*

Distance =   0  OK
             1  One error
             2  Two errors 
             ...
            -1  No match

*/


spellcor(X,Y):- 
    (spellcheck(X,Y,0),!;
     spellcheck(X,Y,1)).   


%% spellcheck(Candidatename,Targetname,Discrepancy).

spellcheck(X,X,Error):-!,Error=0.
% Classic Cut Fault  spellcheck(X,X,0):-!.

spellcheck(X,Y,1):-
    spellc1(X,Y),
    !.

spellcheck(X,Y,2):-
    spellc2(X,Y),
    !.

spellcheck(_,_,-1).



% Both Input and candidate must be instantiated.


% Assume lowercase letters only.


spellc1(Name1,Name2):-
    name(Name1,List1),
    name(Name2,List2),
    spell1(List1,List2).

spellc2(Name1,Name2):-
    name(Name1,List1),
    name(Name2,List2),
    spell1(List1,List),
    spell1(List2,List).


%% spell1(Candidate,Target)

spell1([_,_],_):-!,fail.  %% Dont spell on 2 chars
spell1(_,[_,_]):-!,fail. 

spell1([_],_):-!,fail.   %% Dont spell on 1 chars
spell1(_,[_]):-!,fail. 

spell1([],_):-!,fail.    %% Dont spell on 0 chars ( '' )
spell1(_,[]):-!,fail. 

spell1([X|_],[Y|_]):- 
    (digchar(X);   %% don't spellcheck
     digchar(Y)),  %% numbers (not even 8E)
     !,            %% First character must match 
     fail.         %% For speed and precision
               

spell1([X|_],[Y|_]):- 
    X \== Y,
    !,
    fail.     %% First character must match
   

%% These spell errors are disjoint. 
%% swap would have been  meaningless if names were equal.
%% Otherwise, two adjacent equal letters would be swapped as if a correction


spell1(Lise1,Lise2):- 
    
    (oneextra(Lise1,Lise2), 
    \+ Lise2 = [_]); % not spellcheck into 1 letter

    onemissing(Lise1,Lise2);

    onewrong(Lise1,Lise2);

    swap(Lise1,Lise2).    %% swap neighbouring letter. Expensive

%%%     special(Lise1,Lise2).    

digchar(Ascii):- (Ascii >= 48, Ascii =< 57). %% TA-010115



oneextra(Lise1,Lie1):- 
    delete1(_,Lise1,Lie1).

onemissing(Lie1,Lise1):- 
    delete1(_,Lise1,Lie1).

onewrong([X|Y],[X|V]):-!,
    onewrong(Y,V).
onewrong([_|Z],[_|Z]).
    

swap(Lise1,Lise2):-   % O(n**2)  %% Only neighbour swap !
    append(Prefix,[A,B|Rest],Lise1),
    append(Prefix,[B,A|Rest],Lise2).

special(_Lise1,_Lise2):-fail.

/* NEW REGIME

spellcheck_street(X,X):- % only spellcheck
    street_part_name(X).

spellcheck_street(X,Y):- % only spellcheck
    street_part_name(Y), %% street names ???? 
    spellcheck(X,Y,1). 


% Special case of spellcheck streetnames

spellcheck_street(Elgsetergt,Elgeseter_street):- 
    value(spellstreetflag,true),  %% costly 
    splitstreet0(Elgsetergt,Elgseter,_),
    streetroot(Elgeseter_street,Elgeseter),
    spellcheck(Elgseter,Elgeseter,1).   % elgseter = elgeseter      

    

streetroot(Elgeseter_street,Elgeseter):-
    streetstat(Elgeseter_street,_,_,_,_), %% costly
    (ends_with(Elgeseter_street,Elgeseter,'_street');
     ends_with(Elgeseter_street,Elgeseter,'street')).

%% Sigurd Jorsalfarsvei --> sigurd_jorsalfars_street // Give up

*/


%%%%%%%%%%


substreet0(X,Y):- 
    substreet1(X,Y).
substreet0(X,X).


substreet(X,Y):-
    substreet1(X,Y),
    !.                    %% <--- !
substreet(X,X).


substreet1(Oslov,Oslostreet):-
    streetsyn(V),
    ends_with(Oslov,Oslo,V),
    (
    %     ends_with(Oslostreet,Oslo,street); %% New Regime  %% TA-010623
    ends_with(Oslostreet,Oslo,'_street')). 


splitstreet0(Oslov,Oslo,V):- %% TA-000928
   streetsyn(V),
   ends_with(Oslov,Oslo,V).

%
splitstreet(Oslov,Oslo,V):- %% TA-000804
   splitstreet0(Oslov,Oslo,V),
   composite_road(Oslo,_,_).  %% TA-000921 (check real street)
%    

%% NB The s-forms come first

%% Granåsvegen -> Granåstreet  OK, even if this is incorrect in this case
%% ranheimsvegen = ranheimvegen ==> ranheimstreet



% streetsyn(g).  %%   Kong (Inges ..) Stadsing.  
streetsyn(gata).
streetsyn(gate).
streetsyn(gaten).
streetsyn(gt).
streetsyn(v). %% OOPS olav --> ola(street) ! Yggdrasilv
streetsyn(veg).
streetsyn(vegen).
streetsyn(vei).
streetsyn(veien).
streetsyn(vg).
streetsyn(vn).

/* Drop S %% TA-010514

streetsyn(sg).
streetsyn(sgata).
streetsyn(sgate).
streetsyn(sgaten).
streetsyn(sgt).
streetsyn(sv). 
streetsyn(sveg).
streetsyn(svegen).
streetsyn(sveien).
streetsyn(svei).
streetsyn(svg).
streetsyn(svn).

*/


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

%  hashsearch    borrowed  from  makeauxtables.pl   %% TA-010528


lextoresearch(X,[X]):-number(X),!.

lextoresearch(X,[X]):-
    textlength(X,N), %% utility.pl
    N=< 2,
    !,         %% doesn't mean it is found
    toredef(X,_).  %% TA-010627


lextoresearch(X,Z):-
    set_of(Y-Street,lexcandsearch(X,Y,Street),Z).


lexcandsearch(X,Y,Street):-
    lexsplitroad(X,U,Street),
    lexchash(U,Y,_Street).    %% TA-010528

lexchash(U,Y,Street):-
    lexbhash(U,Y,Street). 

lexchash(U,Y,Street):-  % sentruem -> 
    lexdevcand(U,S),    % sentrum
    lexbhash(S,Y,Street).


lexbhash(X,Y,Street):-
   lextorehash0(X,Y),
   toredef(Y,Street).

 
lexdevcand(U,Y):-
	 name(U,[F|V]),
    delete1(_,V,W),
    name(Y,[F|W]).


lexsplitroad(X,Y,street):-
    streetsyn(V),       %% lex.pl
    ends_with(X,Y,V),
    !.
lexsplitroad(X,X,nil).

lextorehash0(X,X).
lextorehash0(X,Y):-
    torehash(X,Y).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

