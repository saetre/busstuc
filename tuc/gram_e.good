%% FILE gram_e.pl  
%% SYSTEM TUC
%% CREATED TA-930310
%% REVISED TA-011005

:-module(gram_e,[]).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%% Consensical Grammar   (Context Sensitive Categorial Attribute Logic Grammar)

%%   p \ q   Phrase p starting with q
%%
%%   p - q   Assume q, try p
%%
%%   p / q   p missing q within 
%%
%%   p = q   Phrase p as defined exactly by q (NB needs begin/end enclosures)
%%
%%   
%%
%%   begin  
%%     ...    Prevents movement from store to text exactly
%%   end
%%
%%   lock  
%%       ....  Prevents movement from store to text temporarily
%%   unlock 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                       %
% Predicates are ordered by a top down calling order    %
%                                                       %
% Grammar Rules are arranged by a greedy heuristics:    %
%  trying the longest possible phrases                  %
%  in decreasing order of probability.                  %
%  If a phrase is analysed as a category,  then         %
%      no longer phrase for that category is possible   %
% The first syntactically and semantically satisfying   %
%   analysis is adopted.                                %
%                                                       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Suffix Conventions 
%
%     Dummy          00
%     Optional       0        ?
%     One (complex)
%     One simple     1
%     One or more    s        +
%     Zero or more   s0       *
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% New Option: Read from Text 

sentence([S]) ---> 
   {value(textflag,true)},  
   !,
   sentence1(S), 
   terminator.


% New Regime. Several sentences on a line, but with decent error message.


sentence([new::P]) --->  
    {value(queryflag,false)}, %%  Only in multi dialog system ( dialog,1)
    declaration(P),
    terminatore, 
    !.

sentence(ListOfS)  --->  
    onesentence(S1),
    { S1 \== error}, 
    check_stop,  
    moresentences(S1,ListOfS).

moresentences(S1,Square) --->
    onesentence(S2),
    evenmore(S1,S2,Square).


evenmore(S1,[],[S1]) ---> []. %% Normal end of list


evenmore(S1,error,[S1,error]) ---> %% Erroneous end of list
    !,
    skip_rest.


evenmore(S1,S2,[S1|Square]) --->     
    moresentences(S2,Square).


onesentence([])   --->  endofline,!.
onesentence(P)     --->  conf_statement(P),terminatore0,!.
onesentence(S)     --->  sentence1(S), terminatore,!.
onesentence(error) --->  skip_rest. 


conf_statement(confirm::TF)   ---> confirm(TF).

confirm(true) ---> [yes].
confirm(false) ---> [no].

endofline ---> terminator,endofline,!.
endofline ---> end_of_line.  %%  runtime routine  (dagrun.pl)


terminatore0 ---> terminatore,!.
terminatore0 ---> []. %% comma

terminatore ---> [and],!. 
terminatore ---> [or],!.    %% Incorrect, but better than errm

terminatore ---> terminator1. %% TA-001104

terminator1 ---> terminator,!. %% TA-001104
terminator1 ---> end_of_line,!. %% TA-001104


sentence1(P) --->     %% Moved before question
    command(P).   %% gi meg bussene fra nth

 
sentence1(item::P)  ---> 
    noun(_,sin,u,n,it:_,P),
    terminator1, %%  NOT and/or here
    !.

sentence1(item::P) --->  
    item(P),
    terminator1,  %% TA-001204 NB NOT and/or! 
    !.
 

sentence1(P)  ---> %% last in Contiguous regime
    {value(queryflag,true)}, 
    implicitq(P).
%    !.  

sentence1(new::P) --->
    greetings0, 
    statement(P).

sentence1(P) --->
    greetings0,
    question(P).

%%% ITEM SECTION

item(P) ---> 
     name_phrase(_IND,_,true,P). 


%%%% COMMAND SECTION


command(do::quit(Message)) ---> quit(Message),toyou0. 

command(do::reply(Ans)) ---> personal(Ans),!. 


command(do::exists(S:Event)::Q) ---> %
    {type(event,Event)},
    dont(N), %% dont worry %% TA-001130
    lexv(_vt1,V,_,fin), 
    {V \== be1, V\==be2}, % is ... 
    name_phrase(_IND,X,P1,P)
       \ w(name(tuc,n,program)),
%    !,                           % hazardous   show/list 

    verb_phrase1(X,S,id,event/real/S:P1) \  %%  do_phrase(X,S,id,event/real/S:P1)- 
                                            % capture clausal_complement
    lexv(_vt2,V,pres,fin),
    {negate(N,P,Q)},

    addressat0.   %% TA-010129  


command(do::hello) ---> 
    greetings.  


addressat0 --->  w(name(tuc,n,_)),!.
addressat0 --->  w(name(hal,n,_)),!. % my alias name
addressat0 --->  [].

%%%%% DECLARATION SECTION


declaration(Tore isa self) --->
    i,   
    be,
    !,
    newatomid(Tore).

declaration(P) ---> 
    newatom(X),  
    be,
    a,
    !,
    noun(_,sin,u,n, X, P).

%%% STATEMENT SECTION    

statement(P) --->  
    statemen(real,P).


%%   (Rule definition)

%%

statemen(NewHere,P) ---> 
    {value(queryflag,false)},
    ifstatement(NewHere,P).

statemen(R,P) --->
    statemes(S,event/R/S,P). 


ifstatement(R,forall(S)::(event/R/S and P => Q)) ---> 
    if1,                  
    statems(S, true,P),  % ands, no if
    then1,
    statemes(S, true,Q). % ands, if


statemen1(R,P) ---> % simple version, with world 
    statem(S,event/R/S,P).


statemes(S,Com,exists(S:Event):: (Com and Q)) --->
    {value(queryflag,false)},
    {type(event,Event)}, %% TA-010421
    {type(event,Event)},
    ifstatement(S,Q).

/* FAILED  collides with is ynq and isq %% TA-010223

statemes(S,Com,P) ---> %% EXPERIMENT %% TA-010216   (I) Congratulate
    w(verb(Congratulate,pres,fin)),
    !,
    statems(S,Com,P) \   %% TA-010122 
        ([i],w(verb(Congratulate,pres,fin))).
*/


statemes(S,Com,P) --->
    statems(S,Com,P).


statems(S,Com,Q) --->          
    statem(S,Com,P),         
    statems0(S,Com,P,Q).


statems0(S,Com,P,P and R) --->  
    and1,
    statem(S,Com,Q),
    statems0(S,Com,Q,R).

statems0(_,_,P,P) ---> [].   


%% Antecipatory Infinitivals


statem(S,Com,P) ---> % to work on holidays is fun %% TA-001123 // fronted temporarily
     {value(textflag,true)},
     infinitive,
     {constrainit(IT,agent)}, 
     verb_phrase1(IT,S,id,CVP),
     !,
     be,
     be_complements(IT,S,Com:P)  - 
        (infinitive, 
         verb_phrase1(IT,S,id,CVP)).



statem(S,Com,P) ---> % it is good to work // fronted temporarily
    {value(textflag,true)},
    thereit,        
    be,
    {constrainit(IT,agent)}, 
    be_complements(IT,S,Com:P).    



statem(S,Com,P) ---> %% Experiment
    thereit,        
    bimodal(Cost,Money),    %% costs , takes, lasts
    {constrainit(IT,Money)},
    verb_phrase1(IT,S,id,Com:P) \
        w(verb(Cost,pres,fin)).  %   koster penger aa ta buss
  

statem(S,Com,P) --->             
    it,
    be,        
    noun_phrase(X,X1,Q),
    rel(X),
    state(S,Com,P)  -  noun_phrase(X,X1,Q).

statem(S,Com,P) --->  
    it,
    be,
    verb_complement1(Prep,Y,SC,P3),
    that,
    state(S,Com,P)  -  verb_complement1(Prep,Y,SC,P3).

statem(S,Com,Q) --->
    state(S,Com,Q). 


statem(S,Com,P) ---> 
   {value(textflag,true)},
   adverbial2(Prep,Y,SC,P3),
   state(S,Com,P)  -  adverbial2(Prep,Y,SC,P3).    


statem(S,Com,Q) --->
    adverb(Day,Today,pre), 
    state(S,Com,Q)  -                    
        adverb(Day,Today,_). 

statem(S,Com,Q) --->
    adverbial0(Prep,Y,SC,P3), 
    state(S,Com,Q)  -                    
       adverbial1(Prep,Y,SC,P3). 


statem(S,Com,P) ---> % it is good to work
    thereit,        
    be,
    {constrainit(IT,thing)},
    w(adj(Good)),
    !,                %% TA-001123
    be_complements(IT,S,Com:P)
       \ w(adj(Good)). % It is dark tonight 




%-

state(S,Com,Q) --->  
    st(S,N,Com,P),
    {negate(N,P,Q)}. 


state(S,Com,Q) --->    
    it,
    be_truefalse(N),
    that,
    state(S,Com,P),
    {negate(N,P,Q)}.

state(S,Com,Q) --->    
    that,
    state(S,Com,P),
    be_truefalse(N),
    {negate(N,P,Q)}.

st(_,_,_,_) ---> 
    [what],!,fail. %% relwhat is not allowed first

st(_,_,_,_) ---> 
    [who],!,fail. %% relwhat/   who is your creator



st(S,N,Com,P) --->             
    noun_phrase(X,P1,P), 
    verb_phrase(X,S,N,Com:P1).
    

st(S,N,Com,P) --->             
    thereit,       %%             
    be(N),
    st(S,id,Com,P)
         -  w(verb(exist,_,fin)). 

st(S,N,Com,P) ---> 
    thereit,    
    lexv(iv,V,_,fin), %% intrans_verb(V,X,S1,Q,_,fin), 
    st(S,N,Com,P)
         -   lexv(iv,V,_,fin). %% intrans_verb(V,X,S1,Q,_,fin). 

stn(Real,exists(S:Event):: Q) ---> 
    st(S,N,event/Real/S,P), %% 
    {type(event,Event)}, %% TA-010421
    {negate(N,P,Q)}.        %% TA-010223

st0(P) ---> stn(real,P). 

%%%%%%%%%%% QUESTION SECTION %%%%%%%%%%%%%%%%

question(P) ---> whenq(P). % first (what time)

question(P) ---> whichq(P).
question(P) ---> whoq(P).

question(P) ---> whereq(P).
question(P) ---> wherefromq(P).
question(P) ---> whatq(P).
question(P) ---> howadjq(P).
question(P) ---> howmuchq(P).  
question(P) ---> howq(P).
question(P) ---> ppq(P).
question(P) ---> whoseq(P).
question(P) ---> question1(P). 

question1(test::P) ---> question0(P). 

question0(P) ---> hasq(P).
question0(P) ---> isq(P).
question0(P) ---> ynq(P).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


implicitq(_) --->  % this afternoon  ==> causes oo
    this,!,  
    fail.  

implicitq(_) --->  % this afternoon  ==> causes oo
    it,!,
    fail.  

%% Implicit Bus from  to

implicitq(_) ---> %%   at which ... %% TA-010606
    prep1(_),
    which2,
    !,
    fail.


implicitq(modifier(S):: Com12 and P3) ---> 
    namep(_,X,P),
    {constrain(X,vehicle)},
    verb_complements(go,X,S, Com12  :P, event/real/S:P3),
    !.

implicitq(modifier(S):: Com12 and P3) ---> %%   buss i morgen
    namep(_,X,P),
    {constrain(X,vehicle)},
    verb_complements(go,X,S, Com12  :P, event/real/S:P3),
    !. 


implicitq(modifier(S):: Com12 and P3) ---> %%   første buss i morgen
    np_kernel(0,X,W1,W1,true ,P),
    constrainvehdep(X),          %% TA-010619
    verb_complements(go,X,S, Com12  :P, event/real/S:P3),
    !. %%   ( don't waste time )


implicitq(modifier(S):: Com12 and P3) ---> 
    {constrain(X:B,bus)}, 
    verb_complements(go,X:B,S, Com12  :true, event/real/S:P3), 
    !. %%   ( don't waste time )


constrainvehdep(X) ---> {xbottom(X,thing)},!,fail.  %% TA-010619 %% Don't instantiate
constrainvehdep(X) ---> {constrain(X,vehicle)},!.   %%
constrainvehdep(X) ---> {constrain(X,departure)},!. %%



hasq(P) --->  
    has,           
    statement(P)  -  has.


isq(P) --->   
    be,                
    statement(P)  -  be.  

ynq(P) --->
    do,        
    statement(P).      

ynq(P) --->          % not RP
    lexv(iv,Go,A,B), 
    statement(P) -  lexv(iv,Go,A,B).      

 
%%%%%%%%%%%%%%%%%%%%%%%%%%


ppq(WhichX::P) ---> %%  Norwagism
    prep(Prep), 
    whx_phrase(X,WhichX,Q1,Q), 
    lexv(iv,Go,A,B),  
    st0(P) 
         -  ( lexv(iv,Go,A,B),  
            prep(Prep) ,
            noun_phrase1(X,Q1,Q)),
    !.                                  %  CUT !!!  

ppq(WhichX::P) --->
    prep(Prep), 
    whx_phrase(X,WhichX,Q1,Q), 
    be,
    !,                                    %% !!!
    st0(P)
         -  ( be , prep(Prep) ,
                noun_phrase1(X,Q1,Q)).

ppq(WhichX::P) --->       
    prep(Prep),
    whx_phrase(X,WhichX,Q1,Q), 
    do(id), % has  been
    !,                                    %% !!!  
    st0(P) 
         -  ( prep(Prep) ,
            noun_phrase1(X,Q1,Q)).





whichq(WhichX::P) ---> 
    whx_phrase(X,WhichX,Q2,P), 

    !, %% <--- !!! Reintroduced BUT  hvilke plasser ( seter/steder ???) *

    qverb_phrase(X,S,N, event/real/S:Q1), 
    {negate(N,Q1,Q2)}.

whx_phrase(X,WhichX,VP,P) ---> 
    whichf(X,WhichX),
    of,
    npa(X,VP,P).  % of his daughters


whx_phrase(X,WhichX,VP,P) --->
    whichf(X,WhichX), 
    noun_phrase1(X,VP,P) \the(X).

whichf(X,which(X)) ---> which2. %% TA-010421

% whichx(X:_,which(X)) ---> [].


%% What is questions %%%%%%%%%%%% 

whatq(D) ---> %% fronted
     whatbe(1),
     a0,
     w(noun(Y,sin,u,n)),  % what is a bus
     endofline, 
     % terminator,   %% lookahead 
     !, %%% <--- !!!!!
     command(D)- (  lexv(tv,describe,imp,fin),
                    w(quote(Y))).
  

whatq(which(X)::P) --->  %% Moved front
     whatbe(1),   %%   (ref implicit)
     noun_phrase1(X,true,P),  %% np1, but your name is npa, not np1         
     now0. 

whatq(WhichX::P) ---> 
    whatbe(1),
    whx_phrase(X,WhichX,Q2,P) -(which,w(noun(thing,sin,u,n))),
    qverb_phrase(X,S,N, event/real/S:Q1)-be, 
    {negate(N,Q1,Q2)}.


whatq(P) --->  % hva er klokka nå ? 
     whatbe(1),
     the,
     w(noun(Cl,_,_,n)),
     !,
     whichq(P) - (which, w(noun(Cl,_,_,n)), lexv(iv,be1,pres,fin)).

   
%%%%%%%End What Is %%%%%%%%%%%%%%%%



whatq(P) ---> % what time is it now => when is it now  (OK)
    what,
    w(noun(time,_,_,n)),
    !,
    whenq(P) \ [when].


whatq(P) --->
    what,
    do(id),
    whichq(P) \ (which,w(noun(thing,_,u,n)),do). 


%%%%%%%% End Whatq %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


whenq(P) ---> % what time is it (now) => what is the time (now)
    what,     %% TA-010730
    w(noun(time,_,_,n)),
    be,
    it,
    !,
    whatq(P) \ [what],be,[the], w(noun(time,_,_,n)).

whenq(which(Y)::P) ---> %% TA-010421
    when,
    adverbial1(_,Y,Subj,P3) \  
            (prep(in),the(Y),w(noun(time,_,_,n))), 
    question0(P)  -  adverbial1(in,Y,Subj,P3).


whereq(WhichY:: Q and Abra) ---> 
    where,
    be,
    np1(X,A,B),
    w(verb(Go,pres,part)),
    !,
    whx_phrase(Y,WhichY,true,Q) -(which,w(noun(place,sin,u,n))),

    statement(Abra) -  
       ( np1(X,A,B),   w(verb(Go,pres,fin)), prep1(to), gap(Y)).

 


whereq(P) --->  %%  where is nth ? 
    where,
    be,
    % !,  %% where is bus 5 
    ppq(P) \ -(prep(in),which,w(noun(place,_,u,n)),w(verb(lie1,pres,fin))). 


whereq(P) --->  %% where did john go ?
    where,
    ppq(P) \ (prep(in),which,w(noun(place,sin,u,n))). %% TA-001111


whereq(P) --->  %% where did john go to ?
    where,
    whichq(P) \              
      (which,w(noun(place,sin,u,n))). %% TA-001111



wherefromq(which(Y)::P) ---> 
    wherefrom,      %% Make it ADVERBIAL
    adverbial1(_,Y,Subj,P3) \  
            (prep(from),the(Y),w(noun(place,_,_,n))),    
    !,
    question0(P) -      
        adverbial1(in,Y,Subj,P3).
 


whoq(P) --->   
     relpron(agent), 
     whichq(P) \ (which,w(noun(agent,_,u,n))).
 
whoseq(P) --->   % whose dog barked ?    
    whose,
    noun(_,Num,u,n, Y, R), %%
    whoq(P) \ (who,has,art,noun(_,Num,u,n, Y, R),that). 




howq(explain::P) --->
    how,
    infinitive, %% prep1(to),
    !,
    statement(P) \ [i]. %% TA-010228

howq(explain::P) --->
    how,
    do, %% (id),  NOT EMPTY %% TA-010228         
    statement(P).       

/* ???? %% TA-010529

howq(explain::P) ---> %% TA-010529
    how,
    be, 
    whatq(P) \ whatbe1.                    


howq(P) ---> %% TA-010228 %% hvordan er du laget / hvordan er du ?
    how,
    be,
    !,
    whatq(P) \ whatbe1. 
*/



howq(explain::P) --->
    how,
    be,
    statement(P) - be.


% %

howadjq(P) --->  % how far is it from A to B
    [how], 
    howadj(length), %% Only length, not frequency %% hvor often is it a bus 
    be,                %% be/take
    thereit,
    !,     %%  <----    !!!!!
    whatq(P) - ([what],w(verb(be,_,_)),[the],w(noun(length,sin,u,n))). 


howadjq(P) --->  %% how far is A from B
    [how], 
    howadj(length), %% Only length, not frequency %% hvor ofte er det bus *
    be,                %% be/take
    np1(X,Y,Z),
    prep1(_Prep), % from/to
    !,     %%  <----    !!!!!
    whatq(P) \ ([what],w(verb(be,_,_)),[the],w(noun(length,sin,u,n)),
                 prep1(from),np1(X,Y,Z),prep1(to)). 
  

howadjq(which(Y)::P) --->  %% TA-010421
    how,  
    howadj(frequency), % often -> frequency
    !,
    adverbial1(_,Y,Subj,P3) - 
            (prep(with),the(Y),w(noun(frequency,_,_,n))), 

    question0(P)  -  adverbial1(with,Y,Subj,P3).



howadjq(P) --->  %% TA-001220
    how,
    howadj(SIZE), % great -> size
    be,
    !,                    %% <--- !!!
    whichq(P) \ (which,w(noun(SIZE,_,_,n)),w(verb(evah,pres,fin))). 


/* Defunct after optimization

howadjq(P) ---> 
    how,
    howadj(SIZE), % great -> size
    be,
    !,                    %% <--- !!!
    whatq(P) - (what,be,the,w(noun(SIZE,_,_,n)),of). 

*/


howadjq(howmany(X)::P) --->
    how,
    many,
    whichq(which(X)::P) - which .

howmuchq(P) ---> 
    how,much,of,
    whichq(P) \ (which,of). 

howmuchq(P) --->
    how,
    howmuch(Noun), % how much time does
    whichq(P) \(which,w(noun(Noun,_,u,n))). 


howadj(age)        ---> w(adj(old)). 
howadj(delay)     --->  optional(much),w(adj(delayed)).
howadj(distance)   ---> [long].
howadj(duration)   ---> [many],w(noun(minute,plu,_,n)).
howadj(duration)   ---> [long]. 
howadj(duration)   ---> [long],w(noun(time,_,u,n)),!. 
howadj(duration)   ---> much,w(noun(time,_,u,n)),!. 

howadj(frequency)  ---> [often]. %% TA-001220
howadj(frequency)  ---> [many], w(noun(time_count,_,_,n)),inperiod0,!.  

howadj(intelligence) ---> w(adj(intelligent)).
howadj(intelligence) ---> w(adj(stupid)).  %% Rhetorical
howadj(intelligence) ---> great,w(noun(intelligence,sin,_,n)). 

howadj(length)    ---> [far]. 
howadj(length)    ---> w(prep(near)).
howadj(length)    ---> w(adj(long)). 
howadj(length)    ---> many,w(noun(Mile,_,u,n)), %%  meter sin/plu
   {member(Mile,[mil,mile,kilometer,meter])}.

howadj(price)     ---> w(adj(expensive)).
howadj(size)      ---> great.             %% big 

howadj(speed)     ---> [fort].         %%           ??? adverb
howadj(speed)     --->  w(adj(fast)).  %%  ??? adjective

howadj(weight)     ---> w(adj(heavy)). 


/* outdated

howbig(size) ---> great.        %% big 
howbig(age)  ---> w(adj(old)). 
howbig(frequency) ---> [often]. 
howbig(price) ---> w(adj(expensive)). 

*/


% % % 

howmuch(duration)  ---> much, w(noun(time,sin,u,n)),!. 
howmuch(duration)  ---> w(adj(long)), w(noun(time,sin,u,n)),!. 
howmuch(duration)  ---> w(adj(long)). %% maybe also distance 
howmuch(distance)  ---> [far].  
howmuch(thing)     ---> much.


% % % % % % % % % % % % % % % % % % % % % % % % % % % %



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  V E R B  - P H R A S E    S E C T I O N
%
  

% COM is an inherited attribute that shall be under 
% the scope of exists(S)::



verb_phrase(X,S,N,ComP12) --->                %% Complement Combination
    verb_phrase1(X,S,N,ComP1),
    verb_phrases0(X,S,ComP1,  ComP12).     

verb_phrases0(X,S,Com:P1,Com:(P1 and P3)) --->  %% Complement Combination
    andor(and), 
    verb_phrase1(X,S,id, ComP2), 
    verb_phrases0(X,S,ComP2, Com:P3).

verb_phrases0(_,_,ComP1,ComP1) ---> [].


verb_phrase1(X,S,id,ComP2) --->    % local negation of that_verb
    negation(_),                   % indifferent 
    clausal_phrase(X,S,ComP2).     % makes it different from do_phrase
                            
verb_phrase1(X,S,N,ComP2) --->     % be1
    be(N),
    lexv(Iv,Sing,pres,part),       % going  / passing
    { Iv==iv;Iv == tv},  
    !,
    do_phrase(X,S,id,ComP2) \
        w(verb(Sing,pres,fin)).

verb_phrase1(X,S,N,ComP2) --->       % be1  
    amble(X,N),                      % am only if X is a self
    do_phrase(X,S,id,ComP2) \   
        be1.                         % artificial

verb_phrase1(X,S,N,ComP2) --->       %  (be at NTH)
    amble(X,N),                      %% be(N),            
%    there0,         % dummy ( cfr here ) redefined as complement
    be_complements(X,S,ComP2).   

verb_phrase1(X,S,M,ComP2) --->   
    do0(X,M,N),      % to check AM  %% M semantic, N syntactic Negation
    do_phrase(X,S,N,ComP2), 
    !.  %%% <---  !!!               %% HAZARDOUS BUT ESSENTIAL 

amble(_:T,N) ---> [am],!,{type(self,T)},negation(N).
amble(_,N) ---> be(N).



do_phrase(X,S,id,ComP2) ---> %% Tore used a knife for killing John
    use,
    noun_phrase(Y,P,Q),
    prep1(for),
    !,
    w(verb(Kill,pres,part)), %% 
    verb_phrase(X,S,id,ComP2)
       -  ( w(verb(Kill,pres,fin)), %% 
          prep(with),
          noun_phrase(Y,P,Q)).

do_phrase(X,S,id,ComP2) --->
    use,
    noun_phrase(Y,P,Q),
    in_order_to,
    verb_phrase(X,S,id,ComP2)
       -  (prep(with),
          noun_phrase(Y,P,Q)).

do_phrase(X,S,N, Com3P3 ) --->    % Complement Combination % swapped Com3/Com1
    adverbx0,    %% TA-001110%% troglitazone -markedly- reduced the response .
    vp_head(V,X,S,N,  ComP1 ),    
    verb_complements0(V,X,S,ComP1, Com3P3 ).


%%%

vp_head(Give,X,S,id,  Com3:(P1 and Q1)) --->
    {value(textflag,true)},                  %% not nec for buses
    lexv(dtv,Give,_tense,fin), %% TA-010727   btv -> dtv
    noun_phrase1(Y, E1,P1),     
    noun_phrase1(Z,E1,Q1),     
    {dtv_template(Give,X, Y, Z, S,Code)},
    event00(S,Code,Com3,E1).         





vp_head(V,X,S,N,  Com3:P1 ) --->
    lexv(tv,V,_tense,fin), 
    reciproc0(V), 
    negation(N), 
    event00(S,P,Com3,E1),         
    noun_phrase2(X,Y1,E1,P1),     
    {tv_template(V,X,Y1,S,P)}.

vp_head(V,X,S,N,  Com3:E1) --->
    intrans_verb(V,X,S,P,_tense,fin), 
    reciproc0(V), % there0,
    negation(N),
    event00(S,P,Com3,E1). 

vp_head(have,X,S,N,Com:E1) --->  
    has,
    negation(N),  
    noun_phrase2(X,Y,P1,P),
    {has_template(X,Y,P1)},
    {event(S,P,Com,E1)}. 

vp_head(evah,X,S,N,  Com3:P1 ) ---> %% TA-001125 
    lexv(tv,evah,_,fin),  
    negation(N), 
    noun_phrase2(X,Y,P2,P),
    {has_template(Y,X,P2)},         % swap
    event00(S,P,Com3,P1).

vp_head(V,X,S,N,Com:E1) ---> 
    negation(N), 
    intrans_verb(V,X,S,P,_,fin),    %   (Greedy Heuristics)
    there0,    
    event00(S,P,Com,E1). 



% event(S,P,Q,exists(S)::P and Q).  %% fernando.pl

event00(S,P,Q,exists(S:Event)::(P and Q)) --->  %% TA-001228
    {type(event,Event)}. %% TA-010421

%% Clausal Complements %%%%%%%  


clausal_phrase(X,S,Com1:KA) ---> 
    rep_vp(W,TW,X,S,Com2,P2,NewS),   %% vet
    rep_complements0(W,X,S,Com2:P2, Com1:P4),     %% swapped Com1,Com2 000215
    thatto0(W,TW,X),                              % to ===> gap(X)
    event00(NewS,P4,P3,KA), 
    statemen1(NewS,P3). 


thatto0(_W,that,X) ---> infinitive,[] - gap(X). %%   infinitive first
thatto0(_W,TW,_)   ---> that(TW).

thatto0(ask,that,_) ---> []. 
thatto0(believe,that,_) ---> []. 
thatto0(let,that,_) ---> []. 

thatto0(W,that,_) ---> [], 
                       {member(W,[cause,make])}.


rep_vp(let,TW,X,S,Com,KA,NewS) ---> %% I let you go ===> I "let" that you go
     w(verb(let,_,fin)),
     !,
     noun_phrase1(Alfa,Beta,Gamma),
     {rv_template(id,let,TW,X,S,P,NewS)}, 
     event00(S,P,Com,KA),
     [] - noun_phrase(Alfa,Beta,Gamma).

rep_vp(Know,TW,X,S,Com,exists(S:Event):: P and Com,NewS) ---> 
     do(N),
     that_v(Know,_,_),       
     ittobetrue, 
    {type(event,Event)}, %% TA-010421
     {rv_template(N,Know,TW,X,S,P,NewS)}. 


rep_complements0(Say,X,S, ComSubj,Com3P3) --->  
    verb_complements0(Say,X,S, ComSubj, Com3P3).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


be_complements(A,B,C:D) --->  
    w(verb(be,pres,part)),     % being
    be_complements(A,B,C:D).     


be_complements(Y,S,Com:P) ---> % only one passive %% TA-001228
    passive(Y,S,Com,P).


be_complements(X,S, Com:P3) --->   %% Complement Combination
    be_complement(X,S, Com:P1),
    be_complements2(X,S,Com:P1,Com:P3). %% s0 %% TA-011005

be_complements2(X,S,Com:P1,P1 and P3) ---> %% TA-011005
   and0,                           %% 
   be_compl(X,S,Com,P2),           %%  (not noun)
   be_complements2(X,S,Com:P2,P3).

be_complements2(_,_,P,P) --->  %% TA-011005
   []. %%  reductant0. 
  

be_complements0(X,S,Com:P1,Com:(P1 and P3)) ---> 
   and0,  
   be_complement(X,S,Com:P2), %%%  be_compl(X,S,Com,P2),           %% (not noun) % Experiment
   be_complements0(X,S,Com:P2,Com:P3). 

be_complements0(_,_,CP,CP) ---> [].

be_complement(X,S,ComP3) ---> %% I am faster than you %% TA-001228
    comparisons(X,S,P2), 
    complementize(S,P2,ComP3).


complementize(S,P,Com:(exists(S:Event)::P and Com)) --->   %% TA-001228
    {type(event,Event)}. %% TA-010421


/*
be_complement(X,S,Com:(exists(S)::P2 and Com)) ---> %% I am faster than you %% TA-001124
    comparisons(X,S,P2).                          %% before I am faster
*/


be_complement(X,S,Com:P2) ---> 
    ap(A,X,S,Com2,P1),
    verb_complements0(adj/A,X,S,Com2:P1,Com:P2). 
 

% be_complement(_,_,P:P) ---> thereit. %% (?) // Misunderstanding %% TA-001124

be_complement(A,B,C:D) ---> 
    be_compl(A,B,C,D).      %% in reduced_rel

be_complement(A,B,C:D) ---> %% 
    be_noun(A,B,C,D).       %% not in reduced_rel


be_compl(X,S,Com,P2) --->
    [able],
    [to],
    do_phrase(X,S,id, Com:P2 ).

be_compl(X,S,Com,P2) ---> %% was called 
    w(verb(call,past,part)),
    do_phrase(X,S,id, Com:P2 ) \
        w(verb(be_named,pres,fin)). 



/* Destroys  Where is the bus going 

be_compl(X,S,Com,P2) ---> 
    w(verb(V,pres,part)),                    %% was singing
    do_phrase(X,S,id,Com:P2)-
        w(verb(V,pres,fin)).                 %% did sing
*/


/*  Only one passive %% TA-001228

be_compl(Y,S,Com,P) --->
    passive(Y,S,Com,P).

*/



be_compl(X,S,Com,P2) ---> 
    sure,
    do_phrase(X,S,Com,id:P2) \ w(verb(know,_,fin)). %%   knowthat


be_noun(X,S,Com,exists(S:Event)::P2) --->  
    noun_phrase(Y,Com,P1),
    {type(event,Event)}, %% TA-010421
    {align(X,Y,S,P1,P2)}.


ap(A,X,S,COM,exists(S:Event)::P and COM) ---> 
     the0,                               %%  the nearest to Oslo
     adverb0(_Medium),  
     {type(event,Event)}, %% TA-010421
     postadj1(A,X,S,P). 



% PASSIVE 


passive(Z,S,Com, Pli and Q) ---> %%  was
    {value(textflag,true)},    
    lexv(dtv,V,past,part),         %%  given
    np1(Y,true,Q),                 %%  a kiss
    whodidit(V,Y,X,B,C),   
    !,
    st(S,id,Com,Pli) \ (noun_phrase(X,B,C),lexv(dtv,V,past,fin),gap(Z),gap(Y)).


passive(Y,S,Com, Pli) ---> 
    adverbx0,              %% a book was earlier studied. <--- %% EXPERIMENT
    lexv(tv,V,past,part),
    adverbx0,              %%  Changed to exclude prep 
    whodidit(V,Y,X,B,C),   
    !,
    st(S,id,Com,Pli) - (noun_phrase(X,B,C),
                        w(verb(V,pres,fin)), %% lexv(tv,V,pres,fin), % e.g. use -->
                        gap(Y)).


whodidit(_V,_Y,X,B,C)--->       %%
    by,
    !,
    noun_phrase1(X,B,C).
 
whodidit(_V,_Y,X,B,C)--->       %%
    begin, %% tore killed john = tore , killed by agent john ###
    np1(X,B,C) = (w(noun(agent,sin,u,n))),
    end,
    !.



by_agent2(V,X,Y,S,Com,P1 and P2) ---> % by mary
    by,
    !,
    event00(S,true,Com,KA),
    noun_phrase1(X,KA,P1),
    {tv_template(V,X,Y,S,P2)}.    


by_agent2(V,X,Y,S,Com,exists(X):: (XisaPerson and P1 and P2 and P3)) --->  % with a gun
    prep1(With),
    !,
    noun_phrase(Z,Com,P1),
    {whodunnit(V,Person)},
    {tidvarp(X,Person,XisaPerson)}, %% TA-010421
    {tv_template(V,X,Y,S,P2)},
    {verb_compl(V,With,X,Z,S,P3)}.

by_agent2(V,X,Y,S,Com,exists(X):: (XisaPerson and P1 and P2)) --->
    {whodunnit(V,Person)},
    {tidvarp(X,Person,XisaPerson)}, %% TA-010421
    {tv_template(V,X,Y,S,P2)},
     event00(S,true,Com,P1).



%% END PASSIVE


% clause after " noun that ... "

xverb_phrase(X,S,N,Com,P2) --->        
    verb_phrase(X,S,N,Com:P2).         

xverb_phrase(Y,S,N,Com,P2) --->
    noun_phrase(X,P,P1), 
    verb_phrase(X,S,N,Com:P2)
         -  noun_phrase(Y,P,P1).  

xverb_phrase(Y,S,N,Com,P2) --->        
    noun_phrase(X,P,P1),               
    be,                                 
    verb_phrase(X,S,N,Com:P2)
         -  (be , noun_phrase(Y,P,P1)).  


% clause after " which noun ... "

qverb_phrase(Y,S,id,Com:P) --->  %% are you doing
    be,
    np1(X,Q,P),
    w(verb(Do1,pres,part)),
    !,
    statem(S,Com,P) -    
        (np1(X,Q,P), w(verb(Do1,pres,fin)), gap(Y)).



qverb_phrase(X,S,id,Com:P) --->  
    do,
    it,
    bimodal(Cost,Money),  
    {constrain(X,Money)},  %%
    to,
    statem(S,Com,P) \       %% 
        (gap(X),           %%  crown = subject 
        xbimodal(Cost,Money),
        that,
        someone).        %% i

qverb_phrase(X,S,N,ComP2) --->  
    verb_phrase(X,S,N,ComP2).    

qverb_phrase(Y,S,N,ComP2) --->  
    do,                                 
    noun_phrase(X,P,P1),          
    hasto0, 
    verb_phrase(X,S,N,ComP2)  - 
         (do , noun_phrase1(Y,P,P1)).  %% noun_phrase 

qverb_phrase(Y,S,N,ComP2) ---> 
    be,
    noun_phrase1(X,P,P1),
    verb_phrase(X,S,N,ComP2)
         -  (be , noun_phrase(Y,P,P1)).  


qverb_phrase(Y,S,N,ComP2) ---> % which colour has the bus
    has,
    noun_phrase1(X,P,P1),
    verb_phrase(X,S,N,ComP2)
        \ ( has, noun_phrase(Y,P,P1)). 


%% If several verb_complements, they are nested first innermost,
%%   and the state is existantiated innermost


verb_complements0(V,X,S,Com1P1,Com12P3) ---> % 1-n for be1, otherwise 0-n
    verb_complements(V,X,S,Com1P1,Com12P3). 

verb_complements0(V,_,_,CP,CP) ---> 
    {\+ V=be1}.

verb_complements(V,X,S,Com1P1,Com12P3) --->
    verb_complement(V,X,S,Com1P1,Com12P2),
    verb_complements10(V,X,S,Com12P2,Com12P3).  % last dominates first


verb_complements10(V,X,S,Com1P1,Com12P3) ---> %% 0-n  %% TA-001129
    and2, %% but.     Hazard:   I live in hell and tomorrow i die
    verb_complements(V,X,S,Com1P1,Com12P3). %% 1-n 

verb_complements10(V,X,S,Com1P1,Com12P3) ---> %% 0-n 
    verb_complements(V,X,S,Com1P1,Com12P3).   %% 1-n (not s0 in case be1)
                                          
verb_complements10(_,_,_,CP,CP) ---> []. % 0


%%  Try Last  %%  I leave now  and tonight I will.. Experiment

verb_complements10(V,X,S,Com1P1,Com12P3) ---> %% 0-n 
    and2,                                     %% but
    verb_complements(V,X,S,Com1P1,Com12P3).   %% 1-n


verb_complement3(Sing,X,Y,SC, (exists(Y):: SC and P))  ---> % Y=T1:_
        st0(P) 
         -  (gap(X),
           lexv(iv,Sing,pres,fin),
           prep(in) , the(Y) , w(noun(time,_,_,n))). 


verb_complement4(Take,X,Y,SC, (exists(Y):: SC and P))  --->
        begin,  
        adverbial1(In,Y,Subj,P3) =
            (prep(in),the(Y),w(noun(time,_,_,n))),
        end,
        !,
        st0(P) 
         -  (gap(X),
           lexv(tv,Take,pres,fin),
           adverbial1(In,Y,Subj,P3)). % NOT noun_complement !
 
verb_complement(_,_,_,CS,CS) ---> thereit. 

% I make you fail ?

% I take a bus in order to reach NTH

verb_complement(V,X,S, (Com1 and Compl):Subj,Com1:KA) ---> % #swapped
    {\+ member(V,[want])},   %% i want (in order) TO 
    in_order_to(V,N), 
    subordinatex(being_the,reason,X,T1,Subord),
    {negate(N,Subord,Subord1)},
    determiner00(T1,Subj,Subord1,KA), 
    {verb_compl(V,in_order_to,X,T1,S,Compl)}. 


verb_complement(Die,X,S,(Com1 and Compl):Subj,Com1:NP3) --->  %% tv before iv
   while(Neg), 
   lexv(tv,Taking,pres,part),                    %% Taking
   verb_complement4(Taking,X,Y,Subj,P3),
   {negate(Neg,P3,NP3)},
   {verb_compl(Die,during,X,Y,S,Compl)}.


verb_complement(Die,X,S,(Com1 and Compl):Subj,Com1:NP3) ---> %  #swap
   while(Neg), 
   lexv(iv,Sing,pres,part),                    %% singing
   verb_complement3(Sing,X,Y,Subj,P3),
   {negate(Neg,P3,NP3)},
   {verb_compl(Die,during,X,Y,S,Compl)}.



verb_complement(V,X,S,(Com1 and Compl):Subj,Com1:P3) --->    % this afternoon #swap
   this, 
   adverbial(Prep,Y,Subj,P3)-(prep(in),this), 
   {verb_compl(V,Prep,X,Y,S,Compl)}.

verb_complement(V,X,S,(Com1 and Compl):Subj,Com1:P3) --->   %  #swap
   {\+ member(V,[ask,tell,know,knowthing])},     %% Ad Hoc 
   adverbial2(Prep,Y,Subj,P3),
   {verb_compl(V,Prep,X,Y,S,Compl)}.

verb_complement(V,X,S,(Compl and Com1):Subj,Com1:P3) ---> 
   adverbial1(Prep,Y,Subj,P3),                               %% lexical order
   {verb_compl(V,Prep,X,Y,S,Compl)}.

verb_complement(Live,X,S,(Com1 and Compl):Subj,Com1:Subj) ---> % #swap
    adverb(Today,DayClass,_), 
    {adv_compl(Live,Today,X,DayClass,S,Compl)}.

                          %% keep order %% TA-010205
verb_complement(Tell,X,S,(Compl and Com1):Subj,Com1:P3) --->  %% Moved last (Greed) #swap
   nil_compl(Tell),    %% {v_compl(Tell,_,nil,_)},    %% More Cautious 
   complement1(nil,Y,Subj,P3),     %% depart from P before depart P
   !,  %%% <---!!!  Hazardous, but essential 
   {verb_compl(Tell,nil,X,Y,S,Compl)}.

verb_complement1(Prep,Y,SC,P3) --->
    v_complement1(Prep,Y,SC,P3). 

verb_complement1(Prep,TX,SC,FI) ---> 
    verb_complement2(Prep,TX,SC,FI).       %% " I go before 1200 am "


v_complement1(Prep,Y,SC,P3) ---> % JUST TO ASSURE complement1 is 
    complement1(Prep,Y,SC,P3).   % not used as a NOUN_complement

% check possible empty (no prep) complement

nil_compl(_) ---> 
    prep1(_),
    !,
    fail.

nil_compl(be/Present) --->
    {adj_compl(Present,_,nil,_)},   %% filter 
     !.   
nil_compl(Tell) --->
    {v_compl(Tell,_,nil,_)},  
    !. 


verb_complement2(Prep,T1,SC, 
       (exists(T1):: SC and Subord))  ---> 
     subordinate(Prep,T1,Subord).

%%   adverbial   verb_complements with unknown verb

adverbial(Prep,TX,SC,FI) ---> 
    adverbial2(Prep,TX,SC,FI).

adverbial(Prep,Y,SC,P3) --->
    adverbial1(Prep,Y,SC,P3).

adverbial0(Prep,Y,SC,P3) ---> %% Once upon a time 
    adverbial1(Prep,Y,SC,P3).

adverbial0(nil,Y,SC,P3) ---> 
    complement1(nil,Y,SC,P3).



adverbial1(Prep,Y,SC,P3) ---> % JUST TO ASSURE complement1 is
    complement1(Prep,Y,SC,P3).   % not used as a NOUN_complement


adverbial2(Prep,T1,SC,KA) ---> 
    subordinate(Prep,T1,Subord),
    determiner00(T1,SC,Subord,KA).


subordinate(Prep,T,P) --->
    subord_conj(Prep,Category,In), 
    subord_clause(In,Category,T,P).  %%

%% in order to

subordinatex(Prep,Reason,X,T:_,P and srel/Prep/Reason/T/S) --->  
    {value(textflag,true)},            %% Hack %% TA-001124
    verb_phrase(X,S,N,ComP2),
    !,
    st0(P) 
         -  (gap(X), verb_phrase(X,S,N,ComP2)).



subordinatex(Prep,Reason,X,T,P) --->  
    v_complement1(Prep,Y,SC,P3) \
        (prep(Prep),the(T),w(noun(Reason,_,_,n))), 
    !,
    st0(P) 
         -  (gap(X),adverbial1(Prep,Y,SC,P3)).




subord_clause(In,Category,T,P) ---> 
    begin,

    adverbial1(Prep,Y,SC,P3) - (prep(In) , the(T) , w(noun(Category,_,_,n))),
    !,         % !!!

    end, 

    st0(P) 
         -  adverbial1(Prep,Y,SC,P3).



adverb0(X)---> 
    adverb1(X),
    !. %%% FOR GODS SAKE  
adverb0(_) ---> [].



adverb(Today,Day,P) ---> 
    particle(Today),        
    {particle(Today,Day,P)}.


adverbx0 ---> 
      properadverb(X,Y,Z),
      !,
      [] - adverb(X,Y,Z).

adverbx0 ---> [].

properadverb(X,Y,Z) ---> %% TA-001120
    adverb(X,Y,Z),
    {\+ dict_e:preposition(X)}. %% ad hoc

complement1(Nil,Y,SC,P3) ---> %%  ( Bus goes     09.12 => Clock ) at -> nil
    {Nil == nil},
    dendagen0(_),     %% date more probable than clock 
    date(X,P),       %% Buss går lørdag den 09.12 => Date 
    np1(Y,SC,P3) - date(X,P).     



complement1(Nil,Y,SC,P3) ---> 
    {Nil == nil},
    time_phrase(Y,SC,P3), %% bus goes 5 
    !. 

%% The bus goes a sunday %% Expensive ??? 

complement1(Nil,Y,SC,P3) ---> 
   {Nil == nil},
   np1(Y,SC,P3). %% noun_phrase1 



complement1(on,Y,SC,P3) ---> 
    on0,
    day(_),
    date(X,P),       %% Buss går lørdag den 09.12 => Date 
    !, 
    np1(Y,SC,P3) \ date(X,P).     




complement1(Prep,Y,SC,P3) ---> 
    prep(Prep),
    noun_phrasenw(Y,SC,P3). %% not starting with what %% TA-010717

noun_phrasenw(_Y,_SC,_P3)---> relwhat(_),!,fail.      %% TA-010717
noun_phrasenw(Y,SC,P3)---> 
    noun_phrase(Y,SC,P3).   %% TA-010717
                            
streetno ---> [one],!,fail. % one is not a street number 
streetno ---> a,!,fail. %% pure number, not article, not first etc.
streetno ---> w(nb(_,num)), colon, !,fail. % clock ?
streetno ---> num(N), {N < 500}.                              %% 

%%  what does  he see \= which thing that he sees * %% EXPERIMENT TA-010319 

rel_clauses(X,Com,Com and  P) ---> %% Special treatment %% TA-010223
    pronoun(I),     
    {vartypeid(X,T), T\==thing},  %% UGLY %% TA-010319
    !,
    st0(P)-(pronoun(I),gap(X)).   


rel_clauses(X,P,Q) ---> %% that sings and that dances 
    rel_clause(X,P,P1),
    rel_clauses0(X,P1,Q).

rel_clauses0(X,P,Q) --->
    and1,
    rel_clauses(X,P,Q).

rel_clauses0(_,P,P) ---> [].


rel_clause(X,Com,Com and  P) ---> 
    rel(X),
                  %% NOT movement !
         st0(P) - gap(X). 
     

rel_clause(Y,P1,P) --->   %% Internal OF without movement bingoing
    ofx,
        noun_phrase(X,P1 and P2,P),     
        {has_template(X,Y,P2)}. 
 

rel_clause(X,P1,P1 and P2) ---> 
    having,                     
     
       st0(P2) \ (gap(X),has). 
     

%%    a way  to die ==> a way in which someone  die

rel_clause(X,P1,P1 and P2) --->  
%% {constrain(X,way)},  %% TA-001110 %% protein is a -marker- to predict something
    {value(textflag,true)},  %% a bus from vestlia to reach SENTRUM !
    infinitive,   %% to,
    w(verb(Die,pres,fin)),
    verb_complement1(Prep,Y,SC,P3) \ 
          (prep(in),gap(X)),
    stn(real,P2) -  
           (someone,w(verb(Die,pres,fin)),adverbial1(Prep,Y,SC,P3)).


rel_clause(X,P1,P1 and P2) --->  
    {constrain(X,way)},

    doing(Die),

    verb_complement1(Prep,Y,SC,P3)-(prep(in),gap(X)),
    stn(real,P2) -  
           (someone,w(verb(Die,pres,fin)),adverbial1(Prep,Y,SC,P3)).


rel_clause(X,P1, P1 and P2) ---> 
    whose_noun(Z,R),                     
    xverb_phrase(X,S,id,event/real/S,P2) \  
        (has,art,noun(_,_,_,n, Z, R),that).  



rel_clause(X,P1,P2) --->   
%%    {value(textflag,true)}, %% TA-001220 Destroys  where is the (bus going) 
    lexv(iv,Sing,pres,part),  %% What was the problem?
    verb_phrase(X,S,id,(event/real/S and P1):P2)
       \ lexv(iv,Sing,pres,fin). 


rel_clause(X,P1,P2) --->
    lexv(tv,Border,pres,part), 
    verb_phrase(X,S,id,(event/real/S and P1):P2)
       \ lexv(tv,Border,pres,fin). 


rel_clause(Y,P1,P1 and P2) ---> 
    where,
    %  {constrain(Y,place)}
      
        statement(P2)
         -  (prep(in) , the(Y) , w(noun(place,_,_,n))). 
     

rel_clause(Y,P1,P1 and P2) ---> 
    when,
    {constrain(Y,time)},
      
        statement(P2)
         -  (prep(in) , the(Y) , w(noun(time,_,_,n))). 


                                
rel_clause(Y:T,P1,P1 and P2) ---> %% a method for killing john exists
    {value(textflag,true)},
    prep1(for),
    w(verb(Kill,pres,part)),      %% 
    { tv_templ(Kill,_,_)},

    % Rough test  Y can be a complement object of kill

    { bottom(T,Way),stanprep(Prep,Way)}, %% in way/in time/with method
    np1(AA,BB,CC),

    !,
    statement(P2)
         -  ([a],w(noun(agent,sin,u,n)), w(verb(Kill,pres,fin)),
            np1(AA,BB,CC),prep1(Prep),gap(Y:T)).
                                
                                
rel_clause(Y:T,P1,P1 and P2) ---> %% (there is a) way to kiss mary
    {value(textflag,true)},
    infinitive, 
    w(verb(Kiss,_inf,fin)),     %% 
    { tv_templ(Kiss,_,_)},

    % Rough test  Y can be a complement object of kiss

    { bottom(T,Way),stanprep(Prep,Way)}, %% in way/in time/with method
    np1(AA,BB,CC),

    !,
    statement(P2)
         -  ([a],w(noun(agent,sin,u,n)), w(verb(Kiss,pres,fin)),
            np1(AA,BB,CC),prep1(Prep),gap(Y:T)).

                                
rel_clause(Y,P1,P1 and P2) ---> %% (mary is a) woman to kiss
    {value(textflag,true)},
    infinitive, 
    w(verb(Kiss,_inf,fin)),
    % Rough test  Y can be object of kiss
    { tv_templ(kiss,_,Woman)},
    {constrain(Y,Woman)},
    !,
    statement(P2)
         -  ([a],w(noun(agent,sin,u,n)), w(verb(Kiss,pres,fin)),gap(Y)).

       


doing(Die) --->    % to die
    to,
    w(verb(Die,pres,fin)).

doing(Die) --->     % in dying 
    prep1(in),
    w(verb(Die,pres,part)).

doing(Die) --->   % of dying 
    prep1(of),
    w(verb(Die,pres,part)).


% reduced rel   A man (that was) killed

reduced_rel(_,_,_) ---> w(verb(_,pres,fin)),!,fail. %% TA-001101 going OK
reduced_rel(_,_,_) ---> w(verb(be,_,_)),!,fail. 

reduced_rel(X,P1,P1 and P2) --->
    be_compl(X,S,event/real/S,P2). 

whose_noun(Z,R) --->
    whose,
    noun(_,_,u,n, Z, R).  

% whose_noun(Z,R) --->     %% PIED PIPING
%    prep(in),
%    the0,
%    noun(_,_,u,n, Z, R),       
%    of,                   %% the concepts
%    rel(Z),               %% in (the) terms of which
%    the0.                 %% the theory was formulated

relwhat(X) ---> 
    [what],
    {constrain(X,thing)}.

relwhat(X) --->
    [who],
    {constrain(X,agent)}.



rel(X) ---> 
    relpron(P),
    {constrain(X,P)}.

%% METAGRAMMAR SECTION

%% Is this hazardous ???

lock ---> 
    end, %% Don't unblock stack !!!!!!!!!
    !,
    fail.


lock ---> 
    pushstack(+,unlock).   %% This prevents any movement from stack
                           %% until phrase is used up
unlock ---> virtual(unlock).  %% will match unlock on stack
                   

begin ---> 
    pushstack(-,end). %%  This prevents any movement from stack
                            %%  until phrase is used exactly
end ---> virtual(end). %%  will match end on stack


fail  --->  {fail}. %%  METAPROGRAMMING 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

comparisons(X,S,P) ---> 
    comparison(X,S,P1),
    comparisons0(X,S,P1,P).

comparisons0(X,S,P1,P1 and P3) --->
    and1,
    comparison(X,S,P2),
    comparisons0(X,S,P2,P3).

comparisons0(_,_,P,P) ---> [].


comparison(X,_,P2) --->  %%  Direct comparison ( 23 > 20 )
    comparator1(REL),    
    noun_phrase1(Y,P1,P2),
    {compare(REL,number,X,Y,P1)}. %% Changed Format

comparison(X,_,P2) --->  %%  Indirect comparison ( John is older than Mary) 
    comparator2(REL,Age),    
    noun_phrase1(Y,P1,P2),
    {compare(REL,Age,X,Y,P1)}. %% %% Changed Format


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  N O U N  - P H R A S E    S E C T I O N
%

% The object is or is not identical to the subject

noun_phrase2(X,X,VP,P) --->
    resiproc(Him),                        % Himself
    noun_phrase1(X,VP,P) \ pronoun(Him).

noun_phrase2(X,Y,P,findalt(diff,X,Y)::(Q and P)) ---> 
    another,
    noun(_,sin,u,n, Y, Q). 

noun_phrase2(_X,Y,P1,P2) --->   %% Y may or may not
    noun_phrase(Y,P1,P2).       %% be qual to X    

%    !. %% <--- PANIC           %% TA-010305  I reach (pass)  a train to Oslo 
%                               %% Mary eats english ! food

                              
noun_phrase(X,P1,P) --->        
    noun_phrases(X,P1,P).

noun_phrases(Z,VP,P2) --->          % 1...more
    noun_phrase1(X,VP,P1),          % 1
    noun_phrases0(X,Z,VP,P1,P2).    % 0...more


noun_phrases0(X,XZ,VP,P1,P1 and P3) ---> 
   {\+ value(textflag,true)}, %% TA-001110   
    andor(_), %% and  (or is treated like and, cant' handle it anyway)
    noun_phrase1(Y,VP,P2),
    noun_phrases0(Y,Z,VP,P2,P3),
    {latin(and,X,Z,XZ)}. 

noun_phrases0(X,XZ,VP,P1,P1 and P3) ---> 
    {value(textflag,true)},        
    andor(and), 
    noun_phrase1(Y,VP,P2),
    noun_phrases0(Y,Z,VP,P2,P3),
    {latin(and,X,Z,XZ)}. 


noun_phrases0(X,XZ,VP,P1,P1 and P3) ---> %%  or -> and  TA-001202
    {value(textflag,true)},              %%  NB NB NB NB NB NB NB
    andor(or), 
    noun_phrase1(Y,VP,P2),
    noun_phrases0(Y,Z,VP,P2,P3),
    {latin(or ,X,Z,XZ)}.                 %%  gives X;Z

noun_phrases0(X,X,_,P,P) ---> []. 



no_phrase(X,P) ---> %% Pure Noun_phrase 
    noun_phrase1(_,true,P)-the(X). 


noun_phrase1(X,P,P and Q)---> 
    relwhat(X),                % I know what a bus is 
    st0(Q) -   
        gap(X).


noun_phrase1(X,P,P) ---> gap(X). 



noun_phrase1(X,VP,P) --->  
    np1(X,VP,P).           % "the car of" before "this car"


noun_phrase1(X,VP,P) --->  %%   bussen ( anaphoric)
    npa(X,VP,P).


noun_phrase1(X,VP,P) --->  
    np2(X,VP,P).           % some other specialties   


noun_phrase1(Z,P1, exists(Z)::(set_of(X,P,Z) and P1)) ---> 
    athe,
    setlist,
    of, 
    no_phrase(X,P). 



% % % % % % % % % % % % % % % % % % % % % % % %

%% np0    np without modifiers 

np0(X,VP,P) --->       %% np without modifiers
    athe0,             %% TA-010319  a Buick
    aname_phrase(_IND,X,VP,P).

np0(X,VP,P) --->
    np_head(_, X,P1,P1,VP, P). 

np0(X,VP,P) --->
    npa(X,VP,P).

np0(X,P,P) --->
    gap(X).





np1000(X,VP,P) --->  %% np1 without blocking 
    np_kernel(Ind, X,P0,P1,VP, P), 
    noun_complements(Ind,X,P0,P1).

np1(X,VP,P) ---> %   Bussen passerer Buenget stasjon 
    np_kernel(Ind, X,P0,P1,VP, P), 
    noun_modifiers(Ind,X,P0,P1).

np_kernel(Ind,X,true,P1,VP ,P1 and Q) --->%  #1
%     athe0, %%  an Acura  included in aname_phrase  
    aname_phrase(Ind,X,VP,Q).

np_kernel(Ind, X,P0,P1,VP ,P) ---> % #2
    np_head(Ind, X,P0,P1,VP, P).
 

% Pragmatix 

%% 8 next busses  \= bus 8  


aname_phrase(_IND,_,_,_) ---> % one bus \== (bus) 1 bus
    [one],
    w(noun(_,_,_,_)), 
    !,
    fail.

aname_phrase(_IND,_,_,_) ---> 
    number(_),
    w(adj(_)), %%     filanepr,  
    !,
    fail.

% dont return (bus) 3 when " 3 noun_plural" 
% unless  time measure

aname_phrase(_IND,_,_,_) ---> 
    number(_), 
    w(noun(Minutes,_plu,_,_)), %% TA-001101 I have 3000 internet addresses
{ \+ measureclass(Minutes)}, 
    !,
    fail.


%% next 8 buses  \= bus 8  

aname_phrase(_IND,_,_,_) ---> 
    the0, 
    filanepr,  
    number(_),
    w(noun(_Noun,plu,_,_)),   % certain, the number was a count !
    !,
    fail. 


aname_phrase(_,_,_,_) ---> %% the station (nearest kolstad)
    w(adj(_Nearest)),      %% AD HOC  %% TA-010302
    w(name(Kolstad,_,_)),
    {\+ number(Kolstad)},  %% TA-010730
    !,
    fail.

aname_phrase(Ind,XT,VP,P1) ---> %% TA-010730
    athe0,                      
    preadjs0(Alist),
    name_phrase(Ind,XT,VP,P0), 
    {preadjs_template(Alist,XT,P0,P1)}.

/* TA-010730
aname_phrase(Ind,X,VP,P1) ---> 
    athe0,                         %% a beautiful Acura  
    adjs10(X,_,P0,P1), 
    name_phrase(Ind,X,VP,P0). 
*/

npa(Y,VP,findit(X)::P)---> 
    its,
    determiner(Y,A and H,VP,P)-art,
    noun_compound(Y,A,_),
    {has_template(X,Y,H)}.


npa(X,P,findit(X)::P) ---> 
    it, 
    {constrain(X,thing)}. 

npa(X,P,findit(X)::P) --->
    this1, 
    {constrainit(X,thing)}.


npa(X:T,VP,findpron(X:T):: (X isa Man) and VP) ---> 
    pronoun(Man),
    {type(Man,T)}.                


%% Your version exists %% TA-010417

npa(X,VP,P) --->  %% TA-010417
    determiner00(X,P1,VP,P),  %  no determiner
    name_complex(X,P1).       %  assume no determiner  


npa(X,VP,P) --->  %% Does it work ? 
    posspron(Man),
    np1(X,VP,P)  
        \ ( this , w(noun(Man,_,_,gen))). 




name_phrase(Ind,X,P,Q and P) ---> %% keep order/isa first %% TA-010313
    namep(Ind,X,Q).


time_phrase(X,P,Q and P) ---> %% When Clock is expected, number is a time
    timeq12(X,Q).             %%       bus goes  5 o clock

npy(X,P,Q) ---> name_phrase(X,P,Q).
npy(X,P,Q) ---> np2(X,P,Q).



filanepr --->  w(adj(first)). 
filanepr --->  w(adj(last)). 
filanepr --->  w(adj(next)). 
filanepr --->  w(adj(previous)).



% % % % % % % % % % % % % % % % % % % % %



np2(X,VP,P) ---> 
    the0,
    prep1(nearest), 
    np_head(0, X2,P02,P12,VP2, P2),
    prep1(_), %% to/for/... who cares
    np1(AA,BB,CC),
    !,
    np1000(X,VP,P) \ (np_head(0, X2,P02,P12,VP2, P2),prep1(near), np1(AA,BB,CC)).

%  np1 calls noun_modifiers which locks



%% This mans wifes house =  man has wife and wife has house

np2(X,VP,P) ---> 
    number(1:_),
    ofthe,
    np_head(Ind, X,P0,P1,VP, P) \ a, 
    noun_complements(Ind,X,P0,P1) \
         (prep(from),this,w(noun(set,_,_,n))).


np2(X,VP,P) --->
    the,
    same,
    noun(_,Num,_,n, Z, K), 
    as,
    np1(X,VP,P) - 
        (the,noun(_,Num,_,n, Z, K),ofx).

np2(X,VP,P)--->                  %% lacks complements !!!!
    quant_pron(Every,Person),
    np1(X,VP,P)
        \ ( [Every],w(noun(Person,_,_,n))). 
% Every is instantiated by now))).



np_head(0, X,P0,P1,VP, find(Y)::( exists(X) :: P0 and YisaP and P1 and HasYX and VP)) --->
    this,  
    noun(_,_Num,_,gen,  Y, YisaP),  
%    !, %% this courses exists 
    preadjs0(Alist),   
    noun_compound(X,Q0,sin),
   {preadjs_template(Alist,X,Q0,P0)},
   {has_template(Y,X,HasYX)}.


np_head(Cind, XT,P0,P1,VP, P) --->  %% Cind = of ,of- complement required
    determiner0(Num,Cind,XT,P1,VP,P),   
    preadjs0(Alist),           %% "hele"
    noun_complex(XT,Q0,Num),  
   {preadjs_template(Alist,XT,Q0,P0)}.
    
noun_complex(X,P,Num) ---> 
    noun_compound(X,P,Num).

noun_complex(X,P,Num) ---> % May return only one
    noun_list(X,P,Num).    % Moved after noun_compound


name_complex(X,P) ---> 
    name_compound(X,P).

this1(X,find(X))     --->  this1.
this1(X,findpron(X)) --->  thisx.



clock_number(N:T) ---> 
    number(N:T),
    { N >= 100}.

bus_number(N:T) --->
    number(N:T),
    { N =< 100 }.

road_number(N:T) ---> 
    number(N:T),
    { N =< 100 }.

%%%%%%%%%%%%  NOUN LIST:  separate single nouns

noun_list(X,Q,Num) --->
    noun(_,Num,u,n, Y, P),      %  first noun decides  Num    
    nlists0(Y,P,X,Q).
 
 
nlists0(X:TX,P, (X,Z):(TX,TZ),P and R) ---> 
     andor(_), 
     noun(_,_,_,n, Y, Q),
     nlists0(Y,Q,Z:TZ,R).

nlists0(X,P,X,P) ---> [].


%%%%%%%%%%%%% COMPOUND    left associative with genitive

name_compound(X,QP) ---> % Must begin with a name
    plausible_name(Y,P,GN1),  
    sine(u,GN1,GN2), 
    ncomps0(GN2,X,Y,P,QP).   % At least 1 more if genitive

noun_compound(X,QP,Num) ---> % X is the innermost
    noun2(Num,u,GN, Y, P),        %% gen or n
    ncomps0(GN,X,Y,P,QP).  


ncomps0(_,X,YT,P,QP) ---> %% days first departure 
    adjs10(X,_,P,P1),  
    ncomps(X,YT,P1,QP).  

ncomps0(n,X,X,P,P and Q) --->   % his (daughter Mary) 
    nameq1(X,Q).


ncomps0(n,X1,X2,P,P) ---> % if previous was n, then optionally no more.
    {compatvar(X1,X2)}.   %% TA-010511

ncomps(X,Y,P,QP) ---> 
    noun2(_,_,GN, Z, Q), %% tt's phone number
    {has_template(Y,Z,H )}, 
    determiner00(Y,P,Q and H,PQH),
    ncomps0(GN,X,Z,PQH,QP).



sine(_,n,gen) --->  [s].  
sine(u,n,n) --->     [].     %% bussen stopper \= bussens stopper
sine(_,gen,gen) ---> [].


% % % % % % % % % % % % % % % % % % %

%% noun_complements(Ind,X,P,Q)  Ind = of/0    OF-complement/ No OF-compl.


noun_modifiers(_OP,_X,P,P) ---> 
    end,                          %% Input  is blocked 
    !,
    begin.                        %% reintroduce block

noun_modifiers(OP,X,P,Q) ---> 
    lock,                    %% Locking is general ( RULE )
        noun_complements(OP,X,P,Q),
    unlock.

/* Too expensive

noun_modifiers(of,Y,P1,P1 and P2) --->   %% don' bingo of
    of,                                  %% of treated specially
    noun_phrase(X,Q1,Q2),
    st0(P2)-  
        (noun_phrase(X,Q1,Q2),has,gap(Y)).
*/



noun_complements(_of,Y,P1,P1 and P2) ---> %% TA-001215 A meaning of life
    of,   
    st0(P2) \
        (gap(Y),w(verb(evah,pres,fin))). %% TA-001125

noun_complements(Ind,X,P,Q) ---> 
    { Ind=0;Ind=name},   
    rel_clauses(X,P,Q).           %% EXPENSIVE


noun_complements(Ind,X,P,Q) ---> 
    { Ind=0;Ind=name},  
    reduced_rel(X,P,Q).           %% EXPENSIVE

noun_complements(0,X,P,Q) --->  % not serial nonnested rel_clauses
    rel_clauses(X,P,Q).       

noun_complements(Ind,X,P,R) --->  % last dominates first
   { Ind \== of,
     Ind \== name}, %% was too expensive  ...from NTNU to Lade  between ...  
    noun_complement(X,P,Q),  
    and0,  
    noun_complements(_,X,Q,R).

noun_complements(0,_,P,P) ---> [] .

noun_complements(name,_,P, P) ---> [] . 

noun_complement(X,P,P and Q) ---> 
    comparison(X,_,Q).            %%  comparisons (TWO KINDS OF LOOPS ?)


noun_complement(X,P1,P1 and P3) ---> 
    negation(N),        
    complement1(Prep,Y,NP2,P3),
    {noun_compl(Prep,X,Y,P2)},
    {negate(N,P2,NP2)}.

/* A class of 25 persons ==> 1 class !

noun_complement(X,P1,P3) ---> 
    negation(N),        
    complement1(Prep,Y,P1 and NP2,P3),
    {noun_compl(Prep,X,Y,P2)},
    {negate(N,P2,NP2)}.
*/

noun_complement(X,P,P and Q) ---> 
    prep(Prep),      % to
    rel(X),                 % which
    st0(Q) -  
        ( prep(Prep),gap(X)).


% complement without preposition is hazardous

noun_complement(B,P,P and DayX) ---> % bus  friday 
     day(Saturday),
     begin,                %% not bus 24.08.2000 = bus 24...
        np1(D,Day,DayX) = w(noun(Saturday,sin,u,n)),
     end, 
    {noun_compl(nil,B,D,Day)},
     !.


noun_complement(B,P,P and R) ---> % bus now
     adverb(Fast,Q,_),
     !,
     {noun_adverb(B,Fast,Q,R)}. %% whatever that may be


 
%
% E N D  NOUN PHRASES
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

determiner0(plu,0, X,P1,P2, quant(eq/N,X)::(P1 and P2)) ---> 
    the0,

    w(adj(FILANEPR)),
    {member(FILANEPR,[first,last,next,previous])},

    number(N:_),
    !,                 %% <--  !
    [] -   w(adj(FILANEPR)). %% free order

determiner0(Plu,0, X,P1,P2, quant(eq/N,X)::(P1 and P2)) --->
    the0,       
    number(N:_),
    {pluralis(Plu,N)}.  

                                    
determiner0(_,of, X,P1,P2, P) --->     % try the file of = a file of
    the,                               % provided 1 of- complements 
    determiner(X,P1,P2,P) \ art.

determiner0(sin,0, X,P1,P2, P) --->    % try the file = this  file
    this1,                             % provided 0 of- complements 
    determiner(X,P1,P2,P) \  this1.      % this 


determiner0(_,0, X,P1,P2, P) --->    % try the file = a  file
    the,                               % provided 0 of- complements 
    determiner(X,P1,P2,P) \ art.


determiner0(_,0, X,P1,P2, P) ---> %%  _ ==> 0 %% EXPERIMENT %% TA-001101
    determiner(X,P1,P2,P).

determiner0(_,0, X,P1,P2, P) ---> %% _ ==> 0 %% EXPERIMENT %% TA-001101
    determiner00(X,P1,P2, P).     


determiner00(X,P1,P2, P) --->   
    determiner(X,P1,P2, P) \ art.


% % % % % % % % % % % % % % % % % % % % % % % 

determiner(X,P,Q,find(X)::( P and Q )) ---> 
     this.

determiner(X,P1,P2, P1 and P2) --->   
    the(X).

determiner(X,P1,P2, exists(X):: P1 and P2 ) ---> 
     only0, 
     art.

determiner(X,P1,P2, forall(X):: P1 => P2 ) --->
    every .

determiner(X,P1,P2, not (exists(X)::( P1 and P2 ))) ---> 
    no .

determiner(X,P1,P2, quant(eq/N,X):: (P1 and P2)) ---> 
    theonly0, 
    number(N:_).

determiner(X,P1,P2, quant(CR/N,X):: (P1 and P2)) --->
    comparator1(CR),
    number(N:_),
    ofthe0.    

determiner(X,P1,P2, quant(gt/2,X)::  (P1 and P2)) --->
    many.                                             

determiner(X,P1,P2, quant(ge/2,X)::  (P1 and P2)) --->
    several.                                             

determiner(X,P1,P2, quant(le/3,X) :: (P1 and  P2)) --->
    a0,
    few. 

%-------------------------------------------------------------------

nounp1(X,P,GN) --->  noun(_,_,_,GN, X, P).
nounp1(X,P,GN) --->  plausible_name(X,P,GN).


plausible_name(N:Type,N isa Class,GN) ---> 
    w(name(N,GN,Class)),
    {atom(N)},
    {type(Class,Type)}.


nounp(X,P) ---> noun(_,_,u,n,X,P).
nounp(X,P) ---> namep(0,X,P). 

noun(Country,Num,U,Gen, X:Country, X isa Country) --->
    w(noun(Country,Num,U,Gen)). 


% Name Noun expressions  (Complicated, and Pragmatic).

namep(0,NT,XP) ---> %% NB 8 hours is also a clock (% fronted%)
    measure(NT,XP).  %% e.g. 5 minutes

namep(name,NT,XP) ---> 
    you,
    nameq(NT,XP)- w(name(tuc,n,program)).



namep(0,NT2,YP) ---> 
    athe0,                                 %
    noun2(SINPLU,BU,n, NT, XP),            %   retning *(en)*    buss  % ta bussen 30/4 
    nameq(N1T1,_),                         %     nth          5        % holdeplassen nth
    {compoundtest(SINPLU,BU,NT,N1T1)},     %   feasability  test %% TA-010308
    {align_noun_name(NT,N1T1,XP,NT2,YP)},  %
    !.                                     %  Avoid multiple returns (e.g. 3)


namep(0,NT,XP) --->      % the 5 bus 
    the,   
    nameq(NT,_),
    noun(_,sin,_,n, NT, XP).

namep(0,NT,YP) --->
    the0,
    nameq1(NT1T1,_),            %  dragvoll (not number !) % TYPE CHECK !
    noun(_,sin,_,n, NT, XP),      %  bus
    {align(NT,NT1T1,_,XP,YP)}.

namep(name,X,Y) ---> 
    the0,               %% 
    nameq(X,Y).         %% Danube

 
%% TA-001203
% compoundtest(SINPLU,BU,NOUNT,NAMET) ---> %%  Check whether noun and name belong together
%    {compoundtest(SINPLU,BU,NOUNT,NAMET)}.   %%  ( pragmatic feasability test)

%% NB New structure of adjnoun_templ 

noun2(Num,U,Gen, X:Stationtype, XStation2) ---> %%  buss rute/ buss stasjon etc
    w(noun(Bus,sin,u,n)),
    w(noun(Station,Num,U,Gen)), 
    {adjnoun_template(Bus,Station,X:Stationtype,XStation2)}, 
    !.
 

noun2(Num,U,Gen, A,B) --->
    noun(_,Num,U,Gen, A,B). 


%% Measures

measure(NT1,YP) ---> 
    number(NU),                       %  5
    noun(M,_,_,n, NT, XP),             %  minutes, hours, days
   {measureclass(M)}, 
   {align_measure(NT,NU,XP,NT1,YP)}.  




%%  Name Expressions

nameq(C,Q) ---> nameq1(C,Q).

nameq(C,Q) ---> nameq2(C,Q).


% Only full dates allowed, try first

nameq1(X,P) ---> %%  ( Buss går 09.12 => Clock)
   date(X,P).


% Definitely a time  

nameq1(X,P) --->
    timeq1(X,P).                 %%  Clock Time Constant, known to be a time

date(Date:TD,Date isa date) --->
     month(MM),
     dayno(DD), 
     year0(YYYY),  
     !,
     {Date= date(YYYY,MM,DD)}, 
     {type(date,TD)},  
     !.                            %% 1997 is not a time

date(Date:TD,Date isa date) --->
     dayno(DD),
     of0,
     month(MM),
     year0(YYYY),  
     !,
     {Date= date(YYYY,MM,DD)}, 
     {type(date,TD)}, 
     !.                            %% 1997 is not a time


dayno(N) ---> w(nb(N,_Num_Ord)), %%  niende
    { N > 0, N =< 31}.

/*     11.30 ==> Nov 30 ***  

month(N) ---> number(N:_), 
    { N > 0, N =< 12}.
*/

month(N) ---> 
    w(name(Jan,n,_)),
    {monthnumber(Jan,N)}. %% fernando.pl


day(D) --->   
    w(noun(D,_,_,_)),
    {dayname(D)}.       %% fernando.pl

year0(N) ---> year(N),!.
year0(YYYY) ---> {this_year(YYYY)}. %% utility.pl


year(Y2K) ---> %% 0-30 = 2000 - 2030
    number(N:_), 
    {N >= 0,   N < 90 , %% pragmatic 
    Y2K is 2000+N},
    !.

year(NN) ---> % Pragmatic  
   number(N:_),
  { N >= 90, N =< 99},
  { NN is 1900 + N}.


year(N) --->  
    number(N:_),
  { N >= 1900, N =< 9999},
    !.

% % % %


timeq1(N:T,N isa clock) ---> 
    time2(N),
    !,                        %% <---   !
    {type(clock,T)}.


timeq12(N:T,N isa clock) ---> 
    time12(N),
    !,                        %% <---   !
    {type(clock,T)}.



nameq1(N:Type,N isa Class) ---> 
    no0,
    w(name(N,_n,Class)), {_n \== gen},
    {  Class == unkn -> value(unknownflag,true);true}, 
%%    {\+ number(N)}, %% avoid 20 august = bus 20  here %% TA-001203
                      %% number 5 goes 
    {type(Class,Type)}.      



nameq1(quote(N):T,quote(N) isa thing) --->  %% avoid quote(X) isa sentence. ???
    w(quote(N)), 
    !,
    {type(sentence,T)}.


nameq1(N:T,N isa clock) --->
    time1(N),
    {type(clock,T)}.        

%% nameq2  Unclassified number
              
nameq2(N:T,N isa number) ---> %% bus 1 becomes  bus (on) day 1
    number(N:T).


nameq2(N:TT,N isa clock) --->    %% time number formally disjoint
    {type(clock,TT)}, 
    number(N:_),
    {N >= 100,
     N =< 2500}.


time12(N) ---> time2(N).
time12(N) ---> time1(N). 

time1(_) ---> [one],!,fail. %% Avoid misunderstandings

time1(_) ---> num(_N),w(noun(time_count,plu,_,_)),!,fail. 

time1(N1) --->
    num(N1), %% w(nb(N1,num)),
    {N1 >= 100, 
    N1 < 2500},      %%  (heuristic)  
    clock0, 
    !.

time1(N1) --->
    num(N),
    {N < 25},        %%   (heuristic)  
    clock0, 
    !,
    {N1 is N*100}.

time2(now) --->    %% TA-010718  between now and 3pm 
    [now].

time2(N) --->      %% NB between 8 and 9 pm ==> (0800,2100) !!! 
     time1(N0),
{    N0 < 2500}, 
     ampm(N0,N).

time2(N) ---> 
     homi(N0),
     ampm(N0,N).

time2(N) --->
     homi(N).

time2(N) ---> 
    w(adj(half)),prep1(past),hours(N1),
    {N is N1*100+30}.

time2(N) ---> 
    w(adj(half)),prep1(past),
    time12(N1), %% half past 1610 = 1640
    {N is N1 +30}.



homi(N) --->
     hours(N1),
     colon0, 
     minutes(N2),
     {N is N1*100 + N2}.  

ampm(N,N) --->  clock. 
ampm(N,N) --->  amtime. 

ampm(N,N1) ---> pmtime, 
    { N > 1200 -> N1 is N;
                  N1 is N+1200 }.





hours(N1) ---> 
    w(nb(N1,num)),
    {N1 < 25}.    

minutes(N1) ---> 
    w(nb(N1,num)),
    {N1 < 60}.    

nameq3(N:T,N isa number) ---> 
    only0,  
    number(N:T).


number(N:Type) --->  %% monday <> 28   
    num(N),
    {type(number,Type)}. 


number(N:Type) --->  %% a hundred ( also a 100) %% TA-001101
    [a],             %% not composite  (a hundred thousand)
    num(N),
    {N=100;N=1000;N=1000000},
    !,
    {type(number,Type)}. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

intrans_verb(be1,X,S,BXS,pres,fin) ---> 
     hasto0, 
     be1,
     {iv_template(be1,X,S,BXS)}.

intrans_verb(Live,X,S,EXS,P,Q) ---> 
    hasto0,
    lexv(iv,Live,P,Q),  
    {iv_template(Live,X,S,EXS)}.


intrans_verb(Live,X,S,EXS,past,fin) ---> % has lived -> did live
    has,                                 %% TA-010228
    lexv(iv,Live,past,part),  
    {iv_template(Live,X,S,EXS)}.



bitrans_verb(Give,To,X,Y,S,BXYS,P,Q) ---> 
    hasto0, 
    lexv(dtv,Give,P,Q), 
    {dtv_template(Give,To,X,Y,S,BXYS)}.



bitrans_verb(Give,To,X,Y,S,BXYS,P,Q) ---> 
    hasto0, 
    lexv(dtv,Give,P,Q), 
    {dtv_template(Give,To,X,Y,S,BXYS)}.


bitrans_verb(Give,To,X,Y,S,BXYS,P,Q) ---> 
    hasto0, 
    lexv(dtv,Give,P,Q), 
    {dtv_template(Give,To,X,Y,S,BXYS)}.


trans_verbs(LM,X,Y,S,Love_and_Marry) --->
     trans_verb(Love,X,Y,S,_,_,_),
     trans_verbs0(Love,LM,X,Y,S,Love_and_Marry).


trans_verbs0(Love,LM,X,Y,S,Love_and_Marry) --->
     andor(and), 
     trans_verb(Marry,X,Y,S,_,_,_),
     trans_verbs0((Love,Marry),LM,X,Y,S,Love_and_Marry).


trans_verbs0(Love,Love,X:_,Y:_,S,Love/X/Y/S) ---> [].



trans_verb(equal,X,Y,S,BXYS,pres,fin) ---> % equal == be equal
     hasto0,
     be,
     {tv_template(equal,X,Y,S,BXYS)}.


trans_verb(Border,X,Y,S,BXYS,P,Q) --->
     hasto0,
     lexv(tv,Border,P,Q), 
     {tv_template(Border,X,Y,S,BXYS)}.


that_verb(Urge,X,S,UXS,P,Q) --->    
     hasto0,
     that_v(Urge,P,Q),
     {rv_template(id,Urge,_,X,S,UXS,_News)}.


that_v(Say,P,Q) ---> 
     lexv(rv,Say,P,Q).     %%   sv = > rn ( rep_verb )


lexv(iv,be1,pres,fin) --->
    be.

lexv(tv,be2,pres,fin) --->
    be.

lexv(tv,be_named,pres,fin) ---> 
    be,
    lexv(_,call,past,part),
    !.


lexv(tv,make,Pres,Fin) --->   %%   make up
    w(verb(make,Pres,Fin)),  
    up0,  
    !.


lexv(T,Go,P,Q) ---> 
    w(verb(have,P,Q)),
    lexv(T,Go,past,part),
    {verbtype(Go,T)},    
    !.


lexv(T,Live,P,Q)--->
     w(verb(Live,P,Q)),
     {verbtype(Live,T)}. 


be_modal(Seems) ---> be,modal(Seems).
be_modal(seem)  ---> w(verb(seem,_,fin)).

modal(Thought) ---> 
    that_v(Thought,past,part), % passive
    tobetrue(_N).    %% negation ?            

modal(Thought) ---> that_v(Thought,_,fin).     % active
modal(think)   ---> w(adj(possible)). 

tobetrue(N)  ---> to,be_truefalse(N).          
tobetrue(id) ---> [].


bimodal(Cost,Money) ---> 
    w(verb(Cost,_,fin)),
    { Cost \== be},   
    {bm_templ(Cost,Money)}. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    A D J E C T I V E   S E C T I O N
% 
%

%  Proper Adjectives before other prefixes    
%  'next 5 bus'  vs '5 next bus'


preadjs0((A,Blist)) ---> 
   adverb0(_Medium), 
   w(adj(A)),
   !,
   preadjs0(Blist).

preadjs0(true)---> [].
 

postadj1(A,X,S, AP) ---> 
     adj12(A,X,S,AP).


adjs10(X,S,OLD,OLD and NEWP) --->   % NOT start with and 
    adj1(_,X,S,NEW),
    adjs10a(X,S,NEW,NEWP).

adjs10(_,_,OLD,OLD) ---> [].

adjs10a(X,S,OLD,OLD and NEWP) ---> % MAY  start with and 
    and0,
    adj1(_,X,S,NEW),
    adjs10a(X,S,NEW,NEWP).

adjs10a(_,_,OLD,OLD) ---> []. 


adjs20(X,S,OLD,OLD and NEWP) --->
    and0,
    adj2(_,X,S,NEW),
    adjs20(X,S,NEW,NEWP).

adjs20(_,_,OLD,OLD) ---> [].



adj12(A,X,S,P) ---> adj1(A,X,S,P).    %% Proper Adjective

adj12(A,X,S,P) ---> adj2(A,X,S,P).    %% Noun/Name Prefix

adj12(A,X,S,P) ---> adj3(A,X,S,P).    %% Adverbial Prefix 

adj1(previous,X,S,BIGX) ---> 
   [next],to,w(adj(last)), 
   {adj_template(previous,X,S,BIGX)}. 

adj1(Big,X,S,BIGX) --->   
    w(adj(Big)), 
    {adj_template(Big,X,S,BIGX)}. 


adj2(Buick,X,S,CarX) ---> 
    w(name(Buick,n,_)),   
    {adjname_template(Buick,X,S,CarX)}. 


adj3(Big,X,S,BIGX) ---> 
    adverb1(_Very),           %% NB Adjectival adverb
    w(adj(Big)),
    {adj_template(Big,X,S,BIGX)}. %% _Very/Big  Drop Distinction 

%% Adjective A treated like an intransitive verb be/A
                                           

adverb1(Very) ---> {adv_templ(Very,_)}.      %% NB Adjectival adverb

%% adverb1(very) ---> [very].
%% adverb1(medium) ---> [medium].  %% made as an adjective (ad hoc)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

prep0(P) ---> prep(P). 
% prep0(intime) ---> [].      %% John died 1645 

prep(P) ---> prep2(P).      % Prepositional Expressions  (1.)
prep(P) ---> prep1(P).      % Preposition                (2.)


prep1(P)---> w(prep(P)).



%%%%%%%%%%%%%%%%%%%%%% ATOMIC SECTION %%%%%%%%%%%%%%%%%%%%%%%%%%%

atom(XT) ---> 
    w(name(X,_NG,_)),   
    {atom_templ(X,XT)}.

atomlist(L) ---> 
    begin, 
      atom1(N1),
      atom1(N2),    
      atoms0(N1-N2,L),
    end.
    
    
atom1(N) ---> 
    w(name(N,n,Class)),  
    {Class \== unkn}.

atoms0(N1,L) ---> 
    atom1(N2),
    atoms0(N1-N2,L).

atoms0(N,N) ---> [].



newatom(XT) --->
    w(name(NN,_,_0)),
    {atom_templ(NN,XT)}.


newatomid(NN) --->  
    w(name(NN,_,_0)).  



%%%% Subordinate elliptic clauses
%
% John died after Mary died
% 
% John died after the time that Mary died in
%           *****     ****                **

subord_conj(after,  time,  in)  --->  prep(after).  
subord_conj(before, time,  in)  --->  prep(before). 
subord_conj(during, time,  in)  --->  while. 
subord_conj(in,     time,  in)  --->  when.  
subord_conj(in,     place ,in)  --->  where.
subord_conj(in,     time , ni)  --->  prep(without). 
subord_conj(until,  time,  in)  --->  until.

subord_conj(because_of,    reason, being_the) --->  because.
subord_conj(because_of,    reason, being_the) --->  if1. 
subord_conj(being_the,     reason, because_of) ---> so_that.


%%%%%%%%%%%%%%%%

a0  ---> a.
a0  ---> [].

a ---> [a].
a ---> [an]. 

art ---> [a].
art ---> [all]. %% Rough
art ---> [an].   
art ---> [any]. 
art ---> [another].  %% TA-010202  EXPERIMENT 
art ---> [one],[or],[more]. 
art ---> [some].

%%%%%%%%%%%%%%%%%

all ---> [all].
all ---> the,set.


and0 ---> and1,then0.
and0 ---> [].

and1 ---> [and]. %%  and/2 is an operator, causes confusion
and1 ---> [but].

and2 ---> [but]. 

andor(butnot) ---> 
    and1,[not], 
    !.

andor(and) ---> and1,do0. 
andor(or)---> [or].


amtime ---> [am],point0.            %% TA-010804  
amtime ---> [a],point0,[m],point0. %% TA-010804 

anorder(a,N)   ---> a,  w(nb(N,ord)).
anorder(the,N) ---> the,w(nb(N,ord)).

another ---> [another].


as ---> [as].

as0 ---> as.
as0 ---> [].

at ---> prep(at). 

athe ---> the.  
athe ---> a.

athe0 ---> athe.    % The book 'ABC'
athe0 ---> [].


%%% BE DO BE DO BE DO


% be ---> be. %%%%%%%   be(id).

be ---> w(verb(be,_,fin)).

be(N) ---> 
   do,
   negation(N),
   has,
   to,
   be.

be(N) --->      
   modal,
   negation(N),
   be.

be(N) --->      
   be,
   negation(N). 
   
be(N) --->
   has,
   negation(N),
   [been].

% be(id) ---> %% Not Correct
%    [been].   
                  %% OOPS   John is not in England

be(not) --->  
    w(verb(fail,_,fin)),
    infinitive, 
    be.

be_truefalse(N) --->  
    be,
    truefalse(N). 

be_truefalse(not) --->  
    w(verb(fail,_,fin)),
    infinitive, %%prep(to),
    be,
    [true].

because ---> [because].


both0 ---> [both].
both0 ---> [].

by ---> [by].

clock0 ---> clock,!.
clock0 ---> [].

clock ---> [o], [clock].
clock ---> [clock].     
clock ---> [oclock].
clock ---> [hours]. 
clock ---> [hour]. 
clock ---> [h].  %% 1800 h.

colon0 ---> colon.
colon0 ---> [].    %% Experiment

colon ---> [':']. 
colon ---> ['.']. % if visible

%% Simple Comparators 

comparator1(eq) ---> [like]. 
comparator1(eq) ---> [equal],to0.
comparator1(eq) ---> [like].
comparator1(eq) ---> prep1(about). %% Rough 
comparator1(ge) ---> greater,than0,[or],[equal],to0. 
comparator1(ge) ---> [not],less,[than].
comparator1(ge) ---> at,[least].
comparator1(gt) ---> greater,[than].
comparator1(gt) ---> prep1(over). %% TA.001013
comparator1(le) ---> less,than0,[or],[equal],to0.
comparator1(le) ---> [no],[more],[than]. 
comparator1(le) ---> [not],greater,[than].
comparator1(le) ---> at,most.
comparator1(lt) ---> less,[than].
comparator1(ne) ---> [different],[from].
comparator1(ne) ---> [except].
comparator1(ne) ---> unequal,to0.
                                                        

%% Derived Comparators 

comparator2(gt,speed) ---> [faster],[than].  %% TA-001124

comparator2(gt,age) ---> older,[than]. 
comparator2(lt,age) ---> younger,[than].

comparator2(gt,size) ---> greater,[than].
comparator2(lt,size) ---> [smaller],[than].

comparator2(gt,complexity) ---> [more],[complex],[than].  
comparator2(lt,complexity) ---> [simpler],[than].

comparator2(gt,latitude) ---> [north],of.
comparator2(lt,latitude) ---> [south],of.

comparator2(gt,longitude) ---> [west],of.
comparator2(lt,longitude) ---> [east],of.

superlative(M,S) ---> superlat(M,S). %%   ( free order )
superlative(M,S) ---> superlat(M,S)-quant0(N),quant0(N).


superlat(max(N),size)      --->   quant0(N), greatest. 
superlat(max(N),latitude)  --->   quant0(N),most,[northern].
superlat(max(N),longitude) --->   quant0(N),most,[western].


superlat(min(N),size)      --->   quant0(N), [smallest]. %%
superlat(min(N),latitude)  --->   quant0(N),most,[southern].
superlat(min(N),longitude) --->   quant0(N),most,[eastern].

dendagen0(D)   ---> on0,               %% any problems here ?
                    dendagen(D),!.
dendagen0(nil) ---> [].                %% 

dendagen(D)   --->  day(D),!. 
dendagen(nil) ---> [],!.       %% 

do0 ---> do. 
do0 ---> []. 


do0(X,_,_) ---> [am],   %% Special test to avoid am being intransitive verb be1
    {\+ type(self,X)}, 
    !,{fail}.         


do0(_,not,id) ---> %% she had not had her breakfast 
    has,
    [not].
%     !.   NB      % she had not a mother ???

do0(_,not,id) --->
    do(not), %% [cannot],
    !.

do0(_,N,id) --->
     do,!, 
     negation(N).

do0(_,N,N) ---> [].  

% do(id) --->  use,to.

do(not) ---> [dont].  %% TA-010223
do(not) ---> [cannot],!.
do(not) ---> [never],!. 


do(N) --->  use,negation(N),to.

do(N) ---> 
    do,
    negation(N),hasto0.

do(id )---> [] .  

do(N) --->      %%%  dont swallow verb have ! 
    has,
    negation(N).


do ---> [can].
do ---> [do].
do ---> [does].  %% not syn do (....> does = inf) 
do ---> may.
do ---> must.     %%
do ---> [will].    %  shall

% do ---> [does].  %% synword
% do ---> [did].   %% synword

dont(not) ---> [don],[t]. %% don't
dont(not) ---> [dont],!.
dont(not) ---> [do],[not],!.

dont(id) ---> [do],!.
dont(id) ---> [].



each ---> [each].
each ---> [all],the.

either0 ---> [either].
either0 ---> [].
 
every ---> [all].
every ---> [every].
every ---> [all],of0,the. 
every ---> [each].    %% of each -/-> that every has
% every ---> [each],of,the.


few ---> [few].

from ---> [from].

great ---> w(adj(great)).
great ---> [big]. % synonym
great ---> [great].
great ---> [high].
great ---> [large]. 
great ---> [tall].

greater ---> [after].
greater ---> [bigger]. % synonym
greater ---> [greater]. 
greater ---> [higher].
greater ---> [later]. 
greater ---> [more],great.
greater ---> [more]. 


greatest ---> [greatest]. % biggest
greatest ---> [biggest].  % biggest
greatest ---> [largest].

has ---> w(verb(have,_,fin)).  

hasto0 ---> has,to.
hasto0 ---> [].

having ---> w(verb(have,pres,part)). 
having ---> w(prep(with)).           


% ...

how ---> [how].
how ---> [why].  


i  ---> [i]. 

if1 ---> [if]. %% if/2 is an operator, causes confusion

in0 ---> [in].
in0 ---> [].

%% in_order_to(let,id) ---> [],!. %% I let you go %% NO,object modifier

in_order_to(go,_) ---> prep1(to),!,fail. %% go to always preposition 

in_order_to(start,id) ---> infinitive,!.
in_order_to(stop,id)  ---> infinitive,!. 
in_order_to(_,not)    ---> prep1(without),infinitive. %% Norwagism
in_order_to(_,id)     ---> in_order_to.


in_order0 ---> in_order,!.
in_order0 ---> [].                   %%

in_order ---> prep(in),[order].     %%

in_order_to ---> prep1(to),notverb,!,fail.

in_order_to ---> in_order0, %%  I go to lade \= I go in order to
                 infinitive.  

in_order_to ---> if1,i, w(verb(want,_,fin)),infinitive.

infinitive ---> [to]. %% not prep1(to). 

notverb ---> art.
notverb ---> [the].  %% A man admitted to the hospital exists %% TA-001123 
notverb ---> w(adj(_)).
notverb ---> w(noun(_,_,_,_)).
notverb ---> w(name(_,_,_)).



it ---> [it].

its ---> [its],own0.

ittobetrue ---> it,to,be,true.
ittobetrue ---> [].

just0 ---> [just],!. 
just0 ---> [right],!.
just0 ---> []. 

latest ---> [last].   

less ---> [before].
less ---> [earlier].
less ---> [less].
less ---> [lower].
less ---> [smaller].

may  ---> [can].
may  ---> [may].

many ---> [many].

modal --->  may.
modal --->  must.
modal ---> [will].

most ---> [most].

much ---> [much].


must ---> [must].
must --->  has,to.

negation(not) ---> [not].
negation(id)  --->  [there] .
negation(id)  --->  [] .  

newyear ---> w(adj(new)),w(noun(year,_,_,_)).
newyear ---> [newyear]. 
no ---> [no].

now0 ---> now,!. 
now0 ---> [today],!. %% TA-011004 
now0 ---> []. 

now ---> just0,[now],!. 


no0 ---> [no], %% w(noun(number,sin,u,n)), %% number 5 = 5
         point0.                  %% no. ==> number .

no0 ---> w(noun(number,sin,u,n)),  %% route  no. 5 %% TA-001208
         point0.    
no0 ---> []. 

of ---> prep1(of). 

of0 ---> of. 
of0 ---> []. 

offrom ---> of.
offrom ---> prep1(from).  

ofthe ---> of,the.

ofthe0 ---> ofthe.
ofthe0 ---> [].

older ---> [older].

on0 ---> prep1(on). 
on0 ---> [].

one ---> [one].  
one ---> w(nb(1,num)). 

ones ---> [ones].  


on0 ---> prep1(on),!.
on0 ---> []. 


only0 ---> [only].
only0 ---> [].

ordinal(N) ---> 
    w(nb(N,ord)).

or1 --> [or]. 

others ---> [others].

own0 ---> [own].
own0 ---> [].

particle(now) ---> now.

particle(X) ---> [X], 
    {particle(X,_,_)}. %% semantic.pl  

particle(hereafter) ---> 
     prep1(from),
     [now],
     on0.

particle(hereafter) ---> 
     [as],
     soon, 
     [as],
     w(adj(possible)).

particle(regularly) ---> %% TA-010117
    [as],
    [usual].

pmtime ---> 
    prep1(in),[the],w(noun(Afternoon,sin,u,n)),
    {member(Afternoon,[afternoon,evening,night])},
    !.

pmtime ---> [pm],point0.               %% TA-010804
pmtime ---> [p],point0,[m],point0.    %% TA-010804

point0 ---> point,!. %% TA-010718  Always Optional
point0 ---> [].

pointNO ---> point,!. %% Optional in case point is  removed 
pointNO ---> {value(nodotflag,true)}. %% []. %% TA-010719

point ---> ['.'].


posspron(self)   --->  [my],own0.  
posspron(man)    --->  [his],own0.
posspron(woman)  --->  [her],own0.
posspron(program)  --->  [your]. %% your = tucs    % cheap %% TA-010417
posspron(person) --->  their,own0.  %% thing

prep2(according_to) ---> [according],to. 
prep2(after)        ---> [just],prep1(after).   
prep2(around)       ---> prep1(at),prep1(about). 
prep2(around)       ---> prep1(at),prep1(around). %% TA-001209 
prep2(around)       ---> w(prep(near)),to. 
prep2(beside)       ---> [next],to.             
prep2(from)         ---> [out],offrom.
prep2(near)         ---> w(prep(near)),to.
prep2(near)         ---> w(prep(near)),by. 
prep2(near)         ---> w(prep(near)),at.  
prep2(nearest)      ---> w(prep(nearest)),to. 
prep2(of)           ---> [up],prep1(of). 
prep2(on)           ---> [as],prep1(of). %%   (as of date
%% prep2(over)         ---> [more],[than]. %%  // determiner
prep2(out_of)       ---> [out],offrom.
prep2(to)           ---> [bound],prep1(for). 
prep2(to)           ---> prep1(on),its0,w(noun(way,sin,u,n)),prep(to).
prep2(to)           ---> umpover,prep1(to). 
prep2(without)      ---> [free],of.
prep2(with)         ---> [using].               
prep2(with)         ---> by,[use],of.       


its0 ---> [its]. 
its0 ---> [the]. 

umpover ---> [up]. 
umpover ---> [down].

pronoun(Man) ---> [He], 
    {dict_e:pronoun(He,Man)}. 

reciproc0(give) ---> [i],!. %% give me   etc....
reciproc0(show) ---> [i],!. %% show me   etc....  
reciproc0(tell) ---> [i],!. %% tell me   etc....  
reciproc0(_)   --->  there0. 

quant_pron(every,person) ---> [all],number(_). 
quant_pron(every,person) ---> [each]. 

quant_pron(every,person) ---> [everybody].
quant_pron(every,person) ---> [everyone].
quant_pron(every,thing)  ---> [everything].

quant_pron(some,person)  ---> [somebody].
quant_pron(some,person)  ---> someone.
quant_pron(some,person)  ---> [one]. 
quant_pron(some,person)  ---> [anybody].
quant_pron(some,person)  ---> [anyone].

quant_pron(some,thing)   ---> [something].
quant_pron(some,thing)   ---> [anything].

quant_pron(no,person)    ---> [nobody].  % none ?
quant_pron(no,person)    ---> [noone].
quant_pron(no,thing)     ---> [nothing]. % none ?

quant_pron(some,vehicle)  ---> [it], %% EXPERIMENT %% TA-010302
    {value(busflag,true)}.  

quant0(+ 1) ---> [].
quant0(+ N) ---> num(N). 
quant0(- N) ---> ordinal(N).


% ... 

relpron(thing) --->  that.
relpron(thing) --->  which.
relpron(thing) --->  what. 
relpron(agent) ---> who.  % whom 


%% relpron(thing) ---> [].     %% (Too Expensive)

/* What did he do ??? TA-01019 EXPERIMENT

relpron(thing) ---> %% Is there a bus (that) I can take ? NB thing
    pronoun(X),
    [] - pronoun(X).  

*/



resiproc(man)    ---> [himself]. 
resiproc(person) ---> [themselves].
resiproc(woman)  ---> [herself]. 
resiproc(thing)  ---> [itself].  

same ---> [same].

set ---> w(noun(set,_,u,n)).

setlist ---> set.  
setlist ---> [list].

several ---> [several].
several ---> [more],[than],one.

so_that ---> [that]. %% TA-010403  Experiment (textflag?)
so_that ---> [so],that.
so_that ---> [in],[order],that.
so_that ---> [so]. 

someone ---> [someone].

soon ---> [soon].  
soon ---> w(adj(fast)). 

statics(avg)     ---> [average],ofthe0.
statics(max(+1)) ---> [maximum],ofthe0. 
statics(min(+1)) ---> [minimum],ofthe0. 
statics(sum)     ---> total,ofthe0.
statics(number)  ---> [number],ofthe0.

sure ---> [sure].


terminator ---> termchar.


termchar ---> ['.']. 
termchar ---> ['?'].
termchar ---> ['!'].

thanks ---> [thanks].  
thanks ---> [thank],[you]. 
thanks ---> [thankyou].
thanks ---> [thank],[s]. %%  thank's

than0 ---> [than].
than0 ---> [].    

that ---> [that].


that0(T)    ---> that(T),!. 
that0(that) ---> []. 

% that(that)    ---> that0.

that(when)    ---> when. 
that(where)   ---> where. 
that(whether) ---> [whether].
that(whether) ---> if1.
that(how)     ---> how.
that(why)     ---> [why].
that(that)    ---> [that]. 

that0 ---> that.
that0 ---> [].

the ---> [the].

the0 --->  [the],!.
the0 --->  [].


their ---> [their].
their ---> [the],[others].

then0 ---> then1,!.
then0 ---> [].

then1 ---> [then].


theonly0 ---> the0,only0.

there0 ---> [there].
there0 ---> [it]. 
there0 ---> [].

thereit ---> [there]. % preliminary subject 
thereit ---> [it].

this -->  [the].  %% Ambiguous
this ---> this1.


this1 ---> {value(textflag,true)},[the]. 
this1 ---> that.  
this1 ---> [these]. % Anaphoric
this1 ---> [this].  % reference
this1 ---> [those].

% thisx is artificial

to ---> prep(to).

to0 ---> to.
to0 ---> [].  

total ---> [total].
total ---> [sum],of.

true ---> [true].

truefalse(id)  --->  [true].
truefalse(id)  --->  [not],[false].
truefalse(not) --->  [false].
truefalse(not) --->  [not],[true].

up0 ---> [up],!. 
up0 ---> []. 

unequal ---> [unequal].
unequal ---> [not],[equal].

until ---> [until].

use ---> w(verb(use,_,fin)).

very ---> [very].


what --->  [what]. 
what --->  which. % which is

whatbe(1) ---> whatbe1,!. 
whatbe(0) ---> []. 

whatbe1 ---> what,be.
whatbe1 ---> [whats].
whatbe1 ---> w(verb(show,_,fin)),[me]. 
whatbe1 ---> w(verb(list,_,fin)). 

when ---> [when]. 
when ---> [which],w(noun(time,_,u,n)).
when ---> [what],w(noun(time,_,u,n)). 

where ---> [where].
where ---> [how],[far].  %% TA-001215

wherefrom ---> prep1(from),[where],!. 
wherefrom ---> [where],prep1(from),!. 
wherefrom ---> [wherefrom]. 

while(not) ---> while0,[not],!. 
while(not) ---> [without],!.
while(id)  ---> while0,!.

while0 ---> while,!.
while0 ---> [].
 
while ---> [while].

who ---> [who].

which ---> [what],w(noun(kind,_,_,_)),of,!. %% (kind only as phrase)
which ---> [which].

which2 ---> which,ofthe0. 
which2 ---> [what].         %%  what time is it ?

whose ---> [whose].      

you ---> [you].

younger ---> [younger].


num(N) ---> w(nb(N,num)). 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% PERSONAL SECTION 


%% Statements  presuming BussTUC is human.
%% The answer is OK whenever adequate

personal(ok) ---> w(adj(sorry)).

personal(pong) ---> [ping]. %% Just kidding

personal(thanks) ---> [bravo].

personal(thanks) ---> [this],be,w(adj(good)). % etc.  

personal(ok) ---> 
    [how],w(verb(be,pres,fin)),[you], feeiling0, now0. %%  :-)


personal(ok) ---> 
    [how],do,[you], do,now0. 

personal(ok) ---> 
    [how],do,[you], w(verb(feel,pres,fin)),now0. 

feeiling0 ---> w(verb(feel,pres,part)). 
feeiling0 ---> w(verb(do1,pres,part)). %% TA-010926
feeiling0 ---> [].

now0 ---> [now],!. 
now0 ---> particle(_),!.
now0 ---> [].



quit(bye) ---> w(adj(good)),[bye].   
quit(bye) ---> w(adj(good)),[night]. 
quit(bye) ---> w(adj(good)),[day].  
quit(bye) ---> [bye].
quit(bye) ---> [exit]. 
quit(bye) ---> [farewell].
quit(bye) ---> [stop].
quit(bye) ---> [goodbye].               
quit(bye) ---> w(verb(quit,pres,fin)).  
quit(bye) ---> w(verb(stop,pres,fin)).  

quit(bye) ---> w(verb(have,_,_)),   %% TA-010505
              [a],w(adj(Good)),w(noun(Day,sin,u,n)),
    {member(Good,[good,nice,happy])},
    {subclass0(Day,time)}.


quit(you_are_welcome) ---> thanks,youverymuch0. %% TA-010506
quit(merry_christmas) ---> w(adj(good)),w(name(christmas,_,_)).
quit(happy_new_year)  ---> w(adj(good)),newyear. 


greetings0 ---> greetings,!.
greetings0 ---> [].

greetings ---> hello.
greetings ---> [hi],!,sludder.
greetings ---> [hello],!,sludder. 
greetings ---> [but].
greetings ---> [o],np0(_,_,_). 

hello ---> [hello]. 
hello ---> [hi]. 
hello ---> [good],helloday.

helloday ---> [afternoon].
helloday ---> [evening].
helloday ---> [morning]. 

sludder ---> [there].
sludder   ---> []. % old chap


toyou0 ---> prep1(to),[you],!. 
toyou0 ---> [].


you0 ---> [you].
you0 ---> [].

very0 ---> [very]. %% if not noise
very0 ---> [].

much0 ---> [much].
much0 ---> [].



youverymuch0 ---> you0,very0,much0.

%%%%%%%%%%% END OF LEXICAL INTERFACE %%%%%%%%%%%



%%%%%%%% END OF GRAMMAR %%%%%%%%%%%%%%%%%%%%%%%% 



%%%%%%%%%%%%%%%%%%%%%%%THE END%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
