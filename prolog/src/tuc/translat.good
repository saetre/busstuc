%% FILE translat.pl.
%% SYSTEM TUC
%% CREATED TA-940218
%% REVISED TA-001027


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%  Skolemization of FOL expressions




clausifystm( JLM ):- 
    newskolem(X),
    clausify(X,Y,[],JLM,CLAUS),
    number(Y),
    writeconjunct(CLAUS,true),
    skolocon := Y. 
                   

clausify(X,Y,L,P,R):- 
    skolem(X,Y,L,P,Q),   
    !, 
    normalise(Q,R).


%%% Reduce scope of Negation and Skolemize 


%% skolem( SkolemVariableNoBefore, Variable after, Scope Chain, Source, Destination)

skolem(_,_,_,variable,_):- 
    !,
    error(skolem,1),
    fail.


skolem(X,Y,CH, exists(AB)::JLM,RES):-
    subcase(AB,(A or B)), 
    !,
    skolem(X,Y,CH, exists(A)::
                   (exists(B)::JLM),RES).

skolem(X,Y,CH, exists(AB)::JLM,RES):-
    subcase(AB,(A,B)), %% not for nested epistemics !
    !,
    skolem(X,Y,CH, exists(A)::
                   (exists(B)::JLM),RES).

skolem(X,Y,CH, exists(A)::JLM,RES):-
    anaphor_bound(CH,A),
    !,
    skolem(X,Y,CH,JLM,RES).

skolem(X,Z,CH, (exists(A)::JLM),RES):-!,
    wbind(X,CH,A,Y), 
    skolem(Y,Z,CH,JLM,RES).

skolem(X,Y,CH,(forall(A)::JLM),RES):-!,
    skolem(X,Y,[A|CH],JLM,RES).



skolem(X,X,_CH,set_of(A,P1,Z),set_of(A,Q1,Z)):-!,
    condiq(P1,Q1). 


%%%% Quantified Expressions with Defaults

skolem(X,X,_,(quant(lt/0,_)::_),false):-!.

skolem(X,X,_,(quant(ge/0,_)::_),true):-!.

skolem(X,Y,CH,(quant(le/0,A)::P),RES):-
    !,
    skolem(X,Y,CH,(quant(eq/0,A)::P),RES).

skolem(X,Y,CH,(quant(lt/1,Z)::P),RES):-
    !, 
    skolem(X,Y,CH,not (exists(Z):: P),RES).

skolem(X,Y,CH,(quant(gt/0,A)::P),RES):-
    !, 
    skolem(X,Y,CH, (exists(A):: P),RES).

skolem(X,Y,CH,(quant(eq/0,A)::P),RES):-
    !, 
    skolem(X,Y,CH, not (exists(A):: P),RES).

skolem(X,Z,CH,(quant(eq/1,Y)::P),RES):-
    !,
    skolem(X,Z,CH,exists(Y)::P,RES). % APPROX


skolem(X,Y,CH,(quant(ge/1,A)::Z),RES):-
    !,
    skolem(X,Y,CH,(exists(A)::Z),RES).


%% Quantified expressions without Defaults
    
skolem(X,Y,CH,(quant(eq/N,U)::P),RES):-   % = 100    as before
    !,
    skolem(X,Y,CH,
         exists(S)::S isa set and 
                    has/set/cardinality/S/N and 
       (forall(U):: has/set/member/S/U => P),RES).

skolem(X,Y,CH,(quant(GT/N,U)::P),RES):- %% TA-001027 % > 100  
    !,
    skolem(X,Y,CH,
         exists(S):: S isa set and 
         (exists(M):: M isa number and 
                     has/set/cardinality/S/M and
                     comp/number/GT/M/N) and    
         (forall(U):: has/set/member/S/U => P),

RES).


/*

skolem(X,Y,CH,(quant(ne/_N,A)::P),RES):- %% TA-000308  (Rough) % 3 men did not see her
    !,                                         
    skolem(X,Y,CH,(quant(eq/0,A)::P),RES).           % = none of the 3 men did see her
    
skolem(X,Y,CH,(quant(GT/N,U)::P),RES):- %% TA-001027
    !,
    skolem(X,Y,CH,
         exists(S)::S isa set and has/set/cardinality/S/M and
                     
         (forall(U):: has/set/member/S/U => P),RES).

skolem(X,X,_,(quant(NE/_,_A)::_),undefined):- 
    \+ (NE = eq),
    !.

*/




skolem(X,Y,CH,(not (quant(EQN,A)::JLM)),RES):-!,
    oppquant(EQN,NEN),
    skolem(X,Y,CH,(quant(NEN,A)::JLM),RES).





skolem(X,Y,CH,(not (exists(A)::JLM)),RES):-!,
    skolem(X,Y,CH,forall(A)::(not JLM),RES).

skolem(X,Y,CH,(not (forall(A)::JLM)),RES):-!,
    skolem(X,Y,CH,exists(A)::(not JLM),RES).

skolem(X,Y,CH,not (P  and  Q),RES):-!,         
    skolem(X,Y,CH,(not P) or (not Q),RES).

skolem(X,Y,CH,not (P or Q),RES):-!,         
    skolem(X,Y,CH,(not P)  and (not Q),RES).

skolem(X,Y,CH,not (not P),RES):-!,
    skolem(X,Y,CH,P,RES).

skolem(X,Y,CH,not (P => Q),RES):-!,
    skolem(X,Y,CH,P and (not Q),RES).

skolem(X,Z,CH, P or Q , P1 or Q1) :-!,
    skolem(X,Y,CH,P,P1),
    skolem(Y,Z,CH,Q,Q1).

skolem(X,Z,CH,P  and  Q,P1  and  Q1):-!,
    skolem(X,Y,CH,P,P1),
    skolem(Y,Z,CH,Q,Q1).

skolem(X,Z,CH,(P => Q) ,N1 or Q1):-!,
    skolem(X,Y,CH,not P,N1),
    skolem(Y,Z,CH,Q,Q1).

skolem(X,Z,CH,(P then Q) ,PTQ):-!,
    skolem(X,Z,CH,(P => Q) ,PTQ).

% skolem(X,Z,CH,(P then Q) ,RES):-!,  
%    skolem(X,Y,CH,not Q,Q1),         %% avoid existential SK
%    skolem(Y,Z,CH,(P => not Q1),RES). %% Very dirty, THEORY ?

skolem(X,X,_,P,P).

%%%%%%%%%%%%%%%%%%%%%%%%%

anaphor_bound(CH,A):-
     ident_member(A,CH). % Utility


oppquant(even,odd).
oppquant(odd,even).

oppquant(eq/0,gt/0):-!.
oppquant(ne/0,eq/0):-!.
oppquant(gt/0,eq/0):-!.
oppquant(ge/0,lt/0):-!. % impossible
oppquant(lt/0,ge/0):-!. % tautology
oppquant(le/0,gt/0):-!.


oppquant(eq/N,ne/N). % 3 men did not live
oppquant(ne/N,eq/N).
oppquant(gt/N,le/N).
oppquant(ge/N,lt/N).
oppquant(lt/N,ge/N).
oppquant(le/N,gt/N).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%  Normalize to Conjunctive Normal Form %%%

normalise(P,R):-
    cnf(P,Q),     
    normprod(Q,R).

% cnf( any formula(and,or) , the same formula in CNF ) 
% Existing order is retained


cnf((P1 and P2) and Q,R):-!,  %% TA-001202 Flatten it !
    cnf(P1 and (P2 and Q),R).


cnf(P and Q,R):-!, % P is simple  wrt and
    cnf(P,PF),
    cnf(Q,QF),
    muand(PF,QF,R). %% Join two flat cnfs


cnf((P1 and P2) or Q,PF):-!, 
    cnf((P1 or Q) and (P2 or Q),PF).

cnf(Q or (P1 and P2) ,PF):-!, 
    cnf((Q or P1) and (Q or P2),PF).

cnf((P1 or P2) or Q,R):-!,  %% TA-001202 Flatten it !
    cnf(P1 or (P2 or Q),R).

cnf(P1 or P2,P1 or P2):-!. % unnec 

cnf(P,P).


%% flatten and


muand((P1 and P2), Q,R):-!,
    muand(P1,(P2 and Q),R).

muand(P,Q,P and Q).




normprod(Clause , R):-
   normsplit(Clause,Posl,Negl),
   !,
   do_something(Posl,Negl,R).


normsplit((P or Q) or R , A,B):-!,
    normsplit(P or (Q or R),A,B).

normsplit((not P) or Q , Posl, [P|Negl]):-!,
    normsplit(Q, Posl , Negl).

normsplit(P or Q , [P|Posl], Negl):-!,
    normsplit(Q, Posl , Negl).

normsplit(not P , [], [P]):-!.
normsplit(Q, [Q], []).

%% do_something   [positives]  [negatives] Result

do_something([],Negl,R):-!,
    doclause(false,Negl,R).

do_something([P],[],P):-!.

do_something([P],Negl,R):-!,
    doclause(P,Negl,R).

do_something(P,Q,R):- 
    non_horn(P,Q,R).

non_horn(PQ,Negl,R):-!,
    remove_duplicates(PQ,P),
    unforgettable(P,P1),
    unsquare(P1,NH), 
    doclause(NH,Negl,R).

doclause(P,[],P):-!.

doclause(P,N,(CONDS => P)):-
    optimize(N,CONDS). 

unforgettable(P,P):-
    \+ forgettable(P),
    !.

unforgettable(_,[]):-!.

forgettable(P):-
    member(true,P);      
    member(event/_/_,P); 
    member(_ isa _,P).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% NEW SKOLEM FUNCTIONS 

%% sk(no,var1,var2,   ,varn).

% To make skolem constants structurally recognizable

wbind(SKM,VCHAIN,SKTERM,SKN):-  
    SKN is SKM+1,
    reverse(VCHAIN,VC), 
    List = [sk,SKM|VC],
    SKTERM =.. List.

wbind(X,_,_V,X). % already constant 


vbind(X,CH,SXCH,Y):-
    var(SXCH),
    !, 
    Y is X +1 ,
    append_atoms('sk',X,SX), 
    plunder(SX,CH,SXCH) .

vbind(X,_,_V,X). % already constant


   
plunder(SX,[],SX):-!.
plunder(SX,[Y|Z],R):-
    plunder((SX/Y),Z,R).


writeconjunct(X,TF):- 
    writeconjunc(X,TF),

    track(2,(nl,
                for((Y is_the K),
                    output(Y is_the K)))).


writeconjunc((P  and  Q),TF):-!,
    writeconjunc(P,TF),
    writeconjunc(Q,TF).

writeconjunc(( P => Q) ,TF):-!,
    wrclause( (P => Q),TF ).

writeconjunc(P,TF):-!, 
    wrclause(P,TF).

wrclause(P,TF):-
    skupdate(P,TF).


skupdate(_,false):-!.
skupdate(P,true):-
    skup(P).

skup(true):-!.
skup(inconsistent):-!.
skup(undefined):-!.   
skup(_ isa thing):-!. 

skup(X isa _):-var(X),!,
    nl,write(' Uninstantiated Constant '),
    nl,
    abort. 

skup(R):-
    test(redundant(R)),
    ! . 

skup(P):-
    skup1(P).


skup1(A => B) :- !,
    track(1,prettyprint(A => B)),  
    assert( (A => B ) ). 


skup1(X isa M):-  
    !,
    premfakt(X isa M),            
    new_focus(X,M).   %% ==> evaluate.pl

skup1(P):-
    premfakt(P). 

%%  Discern between semi permanent and dynamic


premfakt(P):- 
    \+ fact0(P), 
    \+ difact(P), 
    \+ (P = (_ isa Y),testclass(Y)), 
    !,
    assertfact(P),    % new facts are inserted in stack order
    track(1,prettyprint(P)). 

premfakt(_). 

 
assertfact(P):-
    permanence =: 0,
    value(context_id,UID),  
    !, 
    retractall(difact(UID,P)), 
    asserta(difact(UID,P)).       %% reverse order

assertfact(P):-
    permanence =:1,
    !,
    value(context_id,UID), 
    retractall(fact0(P)),
    retractall(difact(UID,P)), 
    assert(fact0(P)).            % straight order


testimpossible(P):-
    explain(false),
    !, 
    value(context_id,UID),     
    retract(difact(UID,P)). 

testimpossible(_).


redundant(equal/X/X/_):-!. %% Somewhat Ad Hoc
    
redundant(P):-
    tautology(P).

tautology(P) :- 
    tautol(P),
    track(2,(nl,write('** removed ** '),nl, write('    '),write(P),nl,nl)).


tautol(( _ => P)):- 
    tauthead(P), 
    !.


tautol( (A => C) ):- %% Assumes Protectable Rules are already handled
    occ(B,A), 
    B==C.


tauthead(true).  
tauthead(X isa _):- ground(X),!.
tauthead(_ isa C):-testclass(C). 

%%%%% Clausify Query %%%%%%%%%%%

%  No Skolemization



clausifyq(QX::Y ,QX::Z):-!, 
    condiq(Y, Z ).

clausifyq(not (exists(X)::Q) , Z):-!,
    condiq(forall(X)::not Q , Z ).

clausifyq((P => Q) , (Z12 => Q) ):- %  clausify query
   condiq(P,Z12),
   !,
   writeconjunct((Z12 => Q),false).  %  no update

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Translate a condition with quantifiers


condiq(P,Z12):-
   condq(P,Z),
   condopt(Z,Z12). 

condopt(Z,Z12):-
   flatlist(Z,FZ),  %% utility.pl
   optimize(FZ,Z12).

condq(set_of(X,Y,Z),set_of(X,Y1,Z)):-!, 
    condiq(Y,Y1). 

condq(aggregate(MAX,X,Y,P,Z),
      aggregate(MAX,X,Y,P1,Z)):-!, 
    condiq(P,P1).

condq((P => Q),(P1 => Q1)):-!,
    condq(P,P1),
    condq(Q,Q1).

condq((P  and  Q)  and  R,Z):-!,
   condq(P  and (Q  and  R),Z).


condq(P and true,Q):-!,      %% TA-000314
    condq(P,Q).              %% peephole

condq(true and  P,Q):-!,     %% TA-000314
    condq(P,Q).              %% peephole



condq(P  and  Q,(P1,Q1)):-!,
    condq1(P,P1),
    condq(Q,Q1).

condq(not (A => B),Z):-!,
    condq(A  and  (not B),Z).

condq(not (not P), Z):-!,
    condq(P,Z).

condq(not P, not Q):-!,
    condiq(P,Q). 

/*
condq(not (P and Q), (not P1) or (not Q1)):-!, 
    condq(P,P1),
    condq(Q,Q1).
 
*/




condq(P,Q):-condq1(P,Q).

%% condq1 compiles a single condition

condq1(not (exists(X)::Q),Q1):-!,
    condq(forall(X)::not Q,Q1).

condq1(not (forall(X)::Q),Q1):-!,
    condq(exists(X)::not Q,Q1).

condq1(forall(_)::P,Z):-!, 
    P=Q, %    replace(P,X,_,Q),      %% replace X with a Free variable
    condq(Q,Z).                      %% Hazardious

condq1(exists(_)::P,Z):-!,
    condq(P,Z).

condq1(quant(N,X)::P,quant(N,X)::Z):-!,
    condiq(P,Z). %

condq1(set_of(X,Y,Z),set_of(X,Y1,Z)):- 
    condiq(Y,Y1).


condq1(not (P and Q), (NP;NQ)):- %% TA-000524
    condq((not P),NP),
    condq((not Q),NQ).    

condq1(not P, not P):-!. %% Too Easy



% Update focus also in questions 

condq1(X isa C,X isa C):- nonvar(X),!,new_focus(X,C).
condq1(P,P).

testquant(CR,A,B):-
   def number/CR/A/B . 

%% optimize(Square list, Condition)
%%
%% Quick and dirty optimization

optimize(A,B):-
    removesfluous(A,A2),
    sortcond(A2,A3), 
    unsquare(A3,B).

% remove conditions that are superfluous in conjunction

removesfluous(X,Z):- 
    rems(X,[],Y),
    reverse(Y,Z).

rems([X|Y],L,Z):- % worse than a successor
     member(T,Y),
     superfluous(X,T), %% 
     !,
     rems(Y,L,Z).

rems([X|Y],L,Z):- %  worse than a predecessor
     member(T,L),
     superfluous(X,T), %% 
     !,
     rems(Y,L,Z).

rems([X|Y],L,Z):-
    !,
    rems(Y,[X|L],Z).

rems([],L,L).


% superfluous(X , Y ).
% X is superfluous in a conjunction with Y

superfluous(true,_).

%% superfluous(X isa _,_):-atom(X).  

superfluous(X,Y):-X==Y.
superfluous(_ isa thing,_). 
superfluous(X isa C,Y isa D):-
    X==Y,
    subclass(D,C). 


% sortcond(X,Y) Y is an optimal sequence

% ground < anything < testclass < numeric

%%
%%  all isa < ground < anything < numeric
%% 

sortcond([],[]):-!.
sortcond(Z1,[A|Z2]):-
    bets(Z1,A,REST), % Z1 is split into an A which is better 
                     % than  REST
    !,
    sortcond(REST,Z2).
sortcond(Z,Z).

% bets(L,X,Y)   X is not worse than any condition in Y

bets([X],X,[]):-!.

bets(Z,ISA,L):-
    superbet(ISA,Z), % try them in this sequence
    delete1(ISA,Z,L). 

superbet(X isa Y,Z):-member(X isa Y,Z). %% easier to read, worse to execute
superbet(X,Z):-member(X,Z),ground(X).
superbet(X,Z):-member(X,Z).

%% Some removals destined for qev optimisation


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

newskolem(Y):-  
    do_count(skolocon), % skolocon := skolocon + 1
    skolocon =: Y.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Hazardous rule
% Check if a unification of the head with a condition
% will lead to a occurrence check anomaly ( infinite tree )

hazardrule(( P => Q)):- 
    occ(A,P),
    \+ A==Q,         %  not identical  ( => tatutology)
    numbervars(Q),
    freshcopy(A,B),  %  avoids occur check hazards
    subsumes(B,Q).

protectrule(P,P). %% Ad Hoc

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
