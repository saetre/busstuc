%% FILE translat.pl.
%% SYSTEM TUC
%% CREATED TA-940218
%% REVISED TA-010628


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%  Skolemization of FOL expressions




clausifystm( JLM ):- 
    newskolem(X),
    clausify(X,Y,[],JLM,CLAUSELIST),
    number(Y),
    writeconjuncts(CLAUSELIST,true),
    skolocon := Y. 
                   

clausify(X,Y,L,P,R):- 
    skolem(X,Y,L,P,Q),   
    !, 
    normalise(Q,R). %% R is a list of tql clauses


%%% Reduce scope of Negation and Skolemize 


%% skolem( SkolemVariableNoBefore, Variable after, Scope Chain, Source, Destination)

skolem(_,_,_,variable,_):- 
    !,
    error(skolem,1),
    fail.

skolem(X,Y,CH, exists(AB)::JLM,RES):-
    subcase(AB,(A,B)), %% not for nested epistemics !
    !,
    skolem(X,Y,CH, exists(A)::
                   (exists(B)::JLM),RES).

skolem(X,Y,CH, exists(A:_)::JLM,RES):-
    anaphor_bound(CH,A),
    !,
    skolem(X,Y,CH,JLM,RES).

skolem(X,Z,CH, (exists(A:_)::JLM),RES):-!,
    varbind(X,CH,A,Y), 
    skolem(Y,Z,CH,JLM,RES).

skolem(X,Y,CH,(forall(A:_)::JLM),RES):-!,
    var(A),     %% TA-001204                 %% fails if not var !!!                           
    skolem(X,Y,[A|CH],JLM,RES).


/*  TA-010421
skolem(X,X,_CH,set_of(A,P1,Z),set_of(A,Q1,Z)):-!, %% ?????????????????????+
    condiq(P1,Q1). 

*/


%%%% Quantified Expressions with Defaults

skolem(X,X,_,(quant(lt/0,_)::_),false):-!.

skolem(X,X,_,(quant(ge/0,_)::_),true):-!.

skolem(X,Y,CH,(quant(le/0,A)::P),RES):-
    !,
    skolem(X,Y,CH,(quant(eq/0,A)::P),RES).

skolem(X,Y,CH,(quant(lt/1,Z)::P),RES):-
    !, 
    skolem(X,Y,CH,not (exists(Z):: P),RES).

skolem(X,Y,CH,(quant(gt/0,A)::P),RES):-
    !, 
    skolem(X,Y,CH, (exists(A):: P),RES).

/*  Keep the numerics  %% TA-001228

skolem(X,Y,CH,(quant(eq/0,A)::P),RES):-
    !, 
    skolem(X,Y,CH, not (exists(A):: P),RES).

*/

skolem(X,Z,CH,(quant(eq/1,Y)::P),RES):-
    !,
    skolem(X,Z,CH,exists(Y)::P,RES). % APPROX


skolem(X,Y,CH,(quant(ge/1,A)::Z),RES):-
    !,
    skolem(X,Y,CH,(exists(A)::Z),RES).


%% Quantified expressions without Defaults
    
skolem(X,Y,CH,(quant(eq/N,U)::P),RES):-   % = 100    as before
    !,
    skolem(X,Y,CH,
         exists(S)::S isa set and 
                    has/set/cardinality/S/N and 
       (forall(U):: has/set/member/S/U => P),RES).

skolem(X,Y,CH,(quant(GT/N,U)::P),RES):- %% TA-001027 % > 100  
    !,
    skolem(X,Y,CH,
         exists(S):: S isa set and 
         (exists(M):: M isa number and 
                     has/set/cardinality/S/M and
                     comp/number/GT/M/N) and    
         (forall(U):: has/set/member/S/U => P),
    RES).


skolem(X,Y,CH,(not (quant(EQN,A)::JLM)),RES):-!,
    oppquant(EQN,NEN),
    skolem(X,Y,CH,(quant(NEN,A)::JLM),RES).


skolem(X,Y,CH,(not (exists(A)::JLM)),RES):-!,
    skolem(X,Y,CH,forall(A)::(not JLM),RES).

skolem(X,Y,CH,(not (forall(A)::JLM)),RES):-!,
    skolem(X,Y,CH,exists(A)::(not JLM),RES).

skolem(X,Y,CH,not (P  and  Q),RES):-!,         
    skolem(X,Y,CH,(not P) or (not Q),RES).

skolem(X,Y,CH,not (P or Q),RES):-!,         
    skolem(X,Y,CH,(not P)  and (not Q),RES).

skolem(X,Y,CH,not (not P),RES):-!,
    skolem(X,Y,CH,P,RES).

skolem(X,Y,CH,not (P => Q),RES):-!,
    skolem(X,Y,CH,P and (not Q),RES).

skolem(X,Z,CH, P or Q , P1 or Q1) :-!,
    skolem(X,Y,CH,P,P1),
    skolem(Y,Z,CH,Q,Q1).

skolem(X,Z,CH,P  and  Q,P1  and  Q1):-!,
    skolem(X,Y,CH,P,P1),
    skolem(Y,Z,CH,Q,Q1).

skolem(X,Z,CH,(P => Q) ,N1 or Q1):-!,
    skolem(X,Y,CH,not P,N1),
    skolem(Y,Z,CH,Q,Q1).

skolem(X,Z,CH,(P then Q) ,PTQ):-!,
    skolem(X,Z,CH,(P => Q) ,PTQ).

% skolem(X,Z,CH,(P then Q) ,RES):-!,  
%    skolem(X,Y,CH,not Q,Q1),         %% avoid existential SK
%    skolem(Y,Z,CH,(P => not Q1),RES). %% Very dirty, THEORY ?

skolem(X,X,_,P,P).

%%%%%%%%%%%%%%%%%%%%%%%%%

anaphor_bound(CH,AE):- %% Interface: typed variables
    match(AE,A:_E),
    !,
    ident_member(A,CH). % Utility    
 
anaphor_bound(CH,A):-
     ident_member(A,CH). % Utility


oppquant(even,odd).
oppquant(odd,even).

oppquant(eq/0,gt/0):-!.
oppquant(ne/0,eq/0):-!.
oppquant(gt/0,eq/0):-!.
oppquant(ge/0,lt/0):-!. % impossible
oppquant(lt/0,ge/0):-!. % tautology
oppquant(le/0,gt/0):-!.


oppquant(eq/N,ne/N). % 3 men did not live
oppquant(ne/N,eq/N).
oppquant(gt/N,le/N).
oppquant(ge/N,lt/N).
oppquant(lt/N,ge/N).
oppquant(le/N,gt/N).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%  Normalize to Conjunctive Normal Form %%%

normalise(P,R):-
    cnf(P,Q),     
    normprod(Q,R). %% R is a list of tql clauses

% cnf( any formula(and,or) , the same formula in CNF ) 
% Existing order is retained



cnf(P and Q,R):-!, % P is simple  wrt and
    cnf(P,PF),
    cnf(Q,QF),
    muand(PF,QF,R). %% Join two flat cnfs


cnf((P1 and P2) or Q,PF):-!, 
    cnf((P1 or Q) and (P2 or Q),PF).

cnf(Q or (P1 and P2) ,PF):-!, 
    cnf((Q or P1) and (Q or P2),PF).

cnf((P1 or P2) or Q,R):-!, 
    cnf(P1 or (P2 or Q),R).

cnf(P,P).


%% flatten and


muand((P1 and P2), Q,R):-!,
    muand(P1,(P2 and Q),R).

muand(P,Q1 and Q2,P and Q):-!,
    muand(Q1,Q2,Q).
  
muand(P1,P2,P1 and P2).



normprod(Claus1 and Claus2,[TQC1|TQC2]):-!,
    normprod0(Claus1,TQC1),
    normprod(Claus2,TQC2).

normprod(Claus1,[TQC1]):-!,
    normprod0(Claus1,TQC1).

normprod0(Clause,XXX) :-
    optclause(Clause,Clause1),
    normprod1(Clause1,XXX).     


normprod1(Clause , R):-
    normsplit(Clause,Posl,Negl),
    !,
    do_something(Posl,Negl,R).


optclause(false or P,Q):-!,
    optclause(P,Q).

optclause(true or _P,true):-!.

optclause(P or Q, R):-!,
   optclause(Q,Q1),
   optcl(P,Q1,R).

optclause(P,P).
  

optcl(_P,true,true):-!. %% P is finished
optcl(P,false,P):-!.  
optcl(P,Q,P or Q).



normsplit((P or Q) or R , A,B):-!,
    normsplit(P or (Q or R),A,B).

normsplit((not P) or Q , Posl, [P|Negl]):-!,
    normsplit(Q, Posl , Negl).

normsplit(P or Q , [P|Posl], Negl):-!,
    normsplit(Q, Posl , Negl).

normsplit(not P , [], [P]):-!.
normsplit(Q, [Q], []).

%% do_something   [positives]  [negatives] Result

do_something([],Negl,R):-!, %% goal clause
    doclause(false,Negl,R).

do_something([P],[],P):-!.  %% unit fact 

do_something([P],Negl,R):-!, %% definite clause
    doclause(P,Negl,R).

do_something(P,Q,R):- 
    non_horn(P,Q,R).

doclause(P,[],P):-!.

doclause(P,N,(CONDS => P)):-
    optimize(N,CONDS). 


non_horn(_PQ,_Negl,true):-!. %% true, In case nonhorn clauses are unwanted

%% In any case, they should be checked for subsumtions  etc


/*

% Non-Horn Clauses    if they are supported

non_horn(PQ,Negl,R):-!,
    remove_duplicates(PQ,P),
    unforgettable(P,P1),
    makedisjunct(P1,NH), 
    doclause(NH,Negl,R).

*/

makedisjunct([P],P):-!.

makedisjunct([A|B],(A;B1)):-!,
    makedisjunct(B,B1).



unforgettable(P,P):-
    \+ forgettable(P),
    !.

unforgettable(_,[true]):-!. %% pling 

forgettable(P):-
    member(true,P);      
    member(event/_/_,P); 
    member(_ isa _,P).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  SKOLEM FUNCTIONS 

%% sk(no,var1,var2,   ,varn).


varbind(SKM,VCHAIN,SKTERM,SKN):-  
    var(SKTERM),
    !,
    SKN is SKM+1,
    reverse(VCHAIN,VC), 
    List = [sk,SKM|VC],
    SKTERM =.. List.

varbind(X,_,_V,X):-!.  % already constant %% TA-001203


   
plunder(SX,[],SX):-!.
plunder(SX,[Y|Z],R):-
    plunder((SX/Y),Z,R).

writeconjuncts(CL,TF):-
    for(member(C,CL),
        writeconjunct(C,TF)),

    track(2,(nl,
                for((Y is_the K),
                    output(Y is_the K)))).


writeconjunct(( P => Q) ,TF):-!,
    wrclause( (P => Q),TF ).

writeconjunct(P,TF):-!, 
    wrclause(P,TF).

wrclause(P,TF):-
    skupdate(P,TF).


skupdate(_,false):-!.
skupdate(P,true):-
    skup(P).

skup(true):-!.
skup(inconsistent):-!.
skup(undefined):-!.   
skup(_ isa thing):-!. 

skup(X isa _):-
    var(X),!,
    nl,write(' Uninstantiated Constant '),
    nl,
    abort. 

skup(R):-
    test(redundant(R)),
    ! . 

skup(P):-
    skup1(P).


skup1(A => B) :- !,
    track(1,prettyprint(A => B)),  
    assert( (A => B ) ). 


skup1(X isa M):-  
    !,
    premfakt(X isa M),            
    new_focus(X,M).   %% ==> evaluate.pl

skup1(P):-
    premfakt(P). 

%%  Discern between semi permanent and dynamic


premfakt(P):- 
    \+ fact0(P), 
    \+ difact(P), 
    \+ (P = (_ isa Y),testclass(Y)), 
    !,
    assertfact(P),    % new facts are inserted in stack order
    track(1,prettyprint(P)). 

premfakt(_). 

 
assertfact(P):-
    permanence =: 0,
    value(context_id,UID),  
    !, 
    retractall(difact(UID,P)), 
    asserta(difact(UID,P)).       %% reverse order

assertfact(P):-
    permanence =:1,
    !,
    value(context_id,UID), 
    retractall(fact0(P)),
    retractall(difact(UID,P)), 
    assert(fact0(P)).            % straight order


testimpossible(P):-
    explain(false),
    !, 
    value(context_id,UID),     
    retract(difact(UID,P)). 

testimpossible(_).


redundant(equal/X/X/_):-!. %% Somewhat Ad Hoc
    
redundant(P):-
    tautology(P).

tautology(P) :- 
    tautol(P),
    track(2,(nl,write('** removed ** '),nl, write('    '),write(P),nl,nl)).


tautol(( _ => P)):- 
    tauthead(P), 
    !.


tautol( (A => C) ):- %% Assumes Protectable Rules are already handled
    occ(B,A), 
    B==C.


tauthead(true).  
tauthead(X isa _):- ground(X),!.
tauthead(_ isa C):-testclass(C). 

%%%%% Clausify Query %%%%%%%%%%%

%  No Skolemization


clausifyq(which(XT)::Y ,which(X)::Z):-
    nonvar(XT), XT= (X:_T),
    !, 
    condiq(Y, Z ).

clausifyq(howmany(XT)::Y ,howmany(X)::Z):- %% TA-010511
    nonvar(XT), XT= (X:_T),
    !, 
    condiq(Y, Z ).


clausifyq(QX::Y ,QX::Z):-!, 
    condiq(Y, Z ).

clausifyq(not (exists(X)::Q) , Z):-!,
    condiq(forall(X)::not Q , Z ).

clausifyq((P => Q) , (Z12 => Q) ):- %  clausify query
   condiq(P,Z12),
   !,
   writeconjunct((Z12 => Q),false).  %  no update

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Translate a condition with quantifiers


condiq(P,Z12):-
   condq(P,Z),
   condopt(Z,Z12). 

condopt(Z,Z12):-
   flatlist(Z,FZ),  %% utility.pl
   optimize(FZ,Z12).

condq(set_of(X,Y,Z),set_of(X,Y1,Z)):-!, 
    condiq(Y,Y1). 

condq(aggregate(MAX,X,Y,P,Z),
      aggregate(MAX,X,Y,P1,Z)):-!, 
    condiq(P,P1).

condq((P => Q),(P1 => Q1)):-!,
    condq(P,P1),
    condq(Q,Q1).

condq((P  and  Q)  and  R,Z):-!,
   condq(P  and (Q  and  R),Z).


condq(P and true,Q):-!, 
    condq(P,Q). 

condq(true and  P,Q):-!, 
    condq(P,Q).  



condq(P  and  Q,P1Q1):-!,
    condq1(P,P1),
    condq(Q,Q1),
    flatround((P1, Q1),P1Q1). %% Ad Hoc  %% TA-010628

condq(not (A => B),Z):-!,
    condq(A  and  (not B),Z).

condq(not (not P), Z):-!,
    condq(P,Z).

condq(not false,true):-!.  %% TA-010628
condq(not true,false):-!.  %% TA-010628


condq(not P, not Q):-!,
    condiq(P,Q). 

/*
condq(not (P and Q), (not P1) or (not Q1)):-!, 
    condq(P,P1),
    condq(Q,Q1).
 
*/




condq(P,Q):-condq1(P,Q).

%% condq1 compiles a single condition

condq1(not (exists(X)::Q),Q1):-!,
    condq(forall(X)::not Q,Q1).

condq1(not (forall(X)::Q),Q1):-!,
    condq(exists(X)::not Q,Q1).

condq1(forall(_)::P,Z):-!, 
    P=Q, %    replace(P,X,_,Q),      %% replace X with a Free variable
    condq(Q,Z).                      %% Hazardious

condq1(exists(_)::P,Z):-!,
    condq(P,Z).

condq1(quant(N,X)::P,quant(N,Y)::Z):-
    nonvar(X), X= (Y:_T_),
    !,
    condiq(P,Z). %

condq1(set_of(X,Y,Z),set_of(X,Y1,Z)):- 
    condiq(Y,Y1).


% Prefer wider scope for or %

/*
condq1(not (P and Q), NPQ):- %%         (NP;NQ)):-
    condq((not P),NP),
    condq((not Q),NQ),
    optor(NP,NQ,NPQ), %% TA-010628
    !.
*/


% Prefer narrow scope for or (Redundant if after wider scope)
condq1(not PQ, (not PQ1)):-  %% TA-010628
    condq(PQ,PQ1),
    !.

optand(false, _,     false):-!.      %% TA-010628
optand(_,     false, false):-!.
optand(true,  P,     P):-!.
optand(P,     true,  P):-!.
optand(P,     Q,    (P,Q)).


optor(false, P,    P):-!.      %% TA-010628
optor(P,     false,P):-!.
optor(true,  _,    true):-!.
optor(_,     true, true):-!.
optor(P,     Q,    (P;Q)).

% Update focus also in questions 

condq1(X isa C,X isa C):- nonvar(X),!,new_focus(X,C).
condq1(P,P).

testquant(CR,A,B):-
   def number/CR/A/B . 

%% optimize(Square list, Condition)
%%
%% Quick and dirty optimization

optimize(A,B):-
    removesfluous(A,A2),
    sortcond(A2,A3), 
    unsquare(A3,B).

% remove conditions that are superfluous in conjunction

removesfluous(X,Z):- 
    rems(X,[],Y),
    reverse(Y,Z).

rems([X|Y],L,Z):- % worse than a successor
     member(T,Y),
     superfluous(X,T), %% 
     !,
     rems(Y,L,Z).

rems([X|Y],L,Z):- %  worse than a predecessor
     member(T,L),
     superfluous(X,T), %% 
     !,
     rems(Y,L,Z).

rems([X|Y],L,Z):-
    !,
    rems(Y,[X|L],Z).

rems([],L,L).


% superfluous(X , Y ).
% X is superfluous in a conjunction with Y

superfluous(true,_).

%% superfluous(X isa _,_):-atom(X).  

superfluous(X,Y):-X==Y.
superfluous(_ isa thing,_). 
superfluous(X isa C,Y isa D):-
    X==Y,
    subclass(D,C). 


% sortcond(X,Y) Y is an optimal sequence

% ground < anything < testclass < numeric

%%
%%  all isa < ground < anything < numeric
%% 

sortcond([],[]):-!.
sortcond(Z1,[A|Z2]):-
    bets(Z1,A,REST), % Z1 is split into an A which is better 
                     % than  REST
    !,
    sortcond(REST,Z2).
sortcond(Z,Z).

% bets(L,X,Y)   X is not worse than any condition in Y

bets([X],X,[]):-!.

bets(Z,ISA,L):-
    superbet(ISA,Z), % try them in this sequence
    delete1(ISA,Z,L). 

superbet(X isa Y,Z):-member(X isa Y,Z). %% easier to read, worse to execute
superbet(X,Z):-member(X,Z),  \+ (X = (not _Y)), ground(X). %% negation at last
superbet(X,Z):-member(X,Z), \+  (X = (not _Y)).            %% TA-010628

transbetcand(X,Z):-member(X,Z),
                 \+  (X = (not _Y)),
                 \+  (X = _Y1;_Y2).

%% Some removals destined for qev optimisation

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

newskolem(Y):-  
    do_count(skolocon), % skolocon := skolocon + 1
    skolocon =: Y.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Hazardous rule
% Check if a unification of the head with a condition
% will lead to a occurrence check anomaly ( infinite tree )

hazardrule(( P => Q)):- 
    occ(A,P),
    \+ A==Q,         %  not identical  ( => tatutology)
    numbervars(Q),
    freshcopy(A,B),  %  avoids occur check hazards
    subsumes(B,Q).

protectrule(P,P). %% Ad Hoc

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
