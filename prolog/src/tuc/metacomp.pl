%% FILE metacomp.pl  EXPERIMENTAL
%% SYSTEM TUC
%% CREATED  TA-940128
%% REVISED  TA-090521

%http://www.sics.se/sicstus/docs/4.1.3/html/sicstus/PlUnit-Tests-and-Production-Systems.html
:- use_module(library(system), [environ/2,datime/1]).

%%% USE %%%%%%%% RS-111118
:- ['../declare.pl'].

:- dynamic plink/0, plonk/0.  %% Defined in utility/utility.pl

%%% SMOKETEST    virtuals are added last

%% VIRTUAL PRODUCTIONS MUST COME FIRST

%%  dcg_x.pl = virtuals.pl + dcg.pl

:- dynamic %gram_module/2,
           %language/1,
           virtf/1, %% the virtual functor
           virtf/2, %% the virtual functor
           virtx/1, %% the virtual expression
           optiprod/1.%% meta clause   (meta(P))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% A / B     means   " A using all of B before success
% A - B     means   " A using (all of) B some time "
% A \ B     means   " A using (all of) B from the beginning " 
% A = B     means   " A using exactly B ( intentionally )

% Runtime routines are placed in utility.pl

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

segram:- %% short %% noursource facilities %% TA-100207
    nodebug, 
    norsource := true,
    consult(gramn),
    makegram.

regram:- %% short 
    nodebug, 
    consult(gramn),
    makegram.


makegram:- 
    nodebug, %% TA-001027
    assert(language(Lang)),
    makegram(Lang).

makegram(Lang):- 
    retractall(virtf(_)),
    retractall(virtx(_)),
    retractall(optiprod(_)), 

    tell('dcg.pl'),
        write('%%%%% AUTOGENERATED BY metacomp.pl %%%%% RS-111118'),nl,write('%% MODIFIED: '),
        datime(When), write(When),nl,
        write('%% Lang is '),write(Lang),nl,
        write('%% :- [\'declare.pl\'].'),nl,
        write(':-op( 731,xfy, ::: ).'),nl,    %% sentence tag  %% TA-090514 
        write(':-op( 730,xfy, :: ).'),nl,     %% lambda infix
        write(':-op( 727,xfy, => ).'),nl,
        write(':-op( 720,xfy, and ).'),nl,
        write(':-op( 715, fy, not ).'),nl,
        write(':-op( 710,xfx, isa ).'),nl,
        gram_module(Lang,G),   
        for((G: (X ---> Y)), genprod(X,Y)),
    told,

    tell('virtuals.pl'),

        for(optiprod(MP), genprod(optional(MP),(MP,!))),

        prite((optional(_,[],X,X) -->[])), 
        for(virtx(B),    genvirt(B)),
    told,
    
    dcg_file(Lang,DCG), 

       %%  appendfiles('virtuals.pl','dcg.pl',DCG), %%% <---
    
     appendfiles('dcg.pl','virtuals.pl',DCG), %% SEQUENCE!

    style_check(-singleton), %% SWI only   

    dcg_module(Lang,D),  
        compile(D:DCG), 

    style_check(+singleton). %% SWI only  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



genprod(X,Y):-
    prod(X,Y,C),
    prite(C).
  

genvirt(A):-
    genprod(A,virtual(A)).

prod(X,Y,(MAX  --> YL)):-
    expandmetahead(X,T,A,Z,MAX),
    expandlist(Y,T,A,Z,YL).

expandlist((Y1,Y2),[H|T],A,Z,(MAX,YL)):-
    !,
    expandmeta(Y1,H,A,B,MAX),
    expandlist(Y2,T,B,Z,YL).

expandlist(Y,[H],A,Z,MAX):-
    expandmeta(Y,H,A,Z,MAX).




expandmetahead(X,T,A,Z,MAX):-
    X =..[H|LIST],
    Parse=[H|T],
    append([H|LIST],[Parse,A,Z],YLIST),
    MAX =.. YLIST.




expandmeta(X,P,Y,Z,MAX):-
    findmetavirts(X),
    em1(X,P,Y,Z,MAX).



em1(A-B,P,X,Y,(pushstack(free ,B,nil,X,BX),MAX)):-  
   !,
   expandmeta(A,P,BX,Y,MAX).

em1(A\B,P,X,Y,(pushstack(first ,B,nil,X,BX),MAX)):-
   !,
   expandmeta(A,P,BX,Y,MAX).

em1(A / B,P,X,Y,(  

   lock(last,X,X1),
   pushstack(last ,B,nil,X1,X2),
   MAX,
   unlock(X3,Y))):-  
   !,
   expandmeta(A,P,X2,X3,MAX).


em1(A = B,P,X,Y,(

   lock(exact,X,X1),
   pushstack(exact ,B,nil,X1,X2),
   MAX,
   unlock(X3,Y))):-  
   !,
   expandmeta(A,P,X2,X3,MAX).




%% em1( Symbol, Appearence, StackIn, StackOut, Code)

em1(Symbol, Appearence, StackIn, StackOut, Code) :-
    myflags(norsource,true),
    !,
    em2(Symbol, Appearence, StackIn, StackOut, Code).

em1(Symbol, Appearence, StackIn, StackOut, Code) :-

    em0(Symbol, Appearence, StackIn, StackOut, Code).

em0(!,!,X,X,!):-!.  %% Standard rendering
em0([],[],X,X,[]):-!.
em0([U],lit(U),X,Y,cc(U,X,Y)):-!.    %%  lit(jeg) 
em0({M:P},{},X,X,{M:P}):-!. 
em0({P},{},X,X,{user:P}):-!.  %%     NB NB write   {P,Q} as {P},{Q}

em0(X,Free,A,Z,MAX):-
    X =..[H|LIST],
    append([H|LIST],[Free,A,Z],YLIST),
    MAX =.. YLIST.


%% not implemented yet
em2(!,!,X,X,!):-!. %% Rendering with whistles
em2([],[],X,X,[]):-!.
em2([U],lit(U),X,Y,cc(U,X,Y)):-!.    %%  lit(jeg) 
em2({M:P},{},X,X,{M:P}):-!. 
em2({P},{},X,X,{user:P}):-!.  

em2(X,Free,A,Z,MAX):- %% e.g. noun(bus,sin,u,n) 
    X =..[H|LIST],
    append([H|LIST],[Free,A,Z],YLIST),
    MAX =.. YLIST.
%%%




findmetavirts( _ / Z):-
    !,
    findvirtuals(Z).

findmetavirts( _ \ Z):-
    !,
    findvirtuals(Z).

findmetavirts( _ - Z):-
    !,
    findvirtuals(Z).

findmetavirts( _  = Z):-
    !,
    findvirtuals(Z).

findmetavirts(C):- 
    findmeta(C).


findmeta(optional(X)):-!,foundmeta(X).
findmeta(_).


foundmeta(X):-  %% TA-100114
    var(X),
    !,
    told, %% make message appear online
    nl,
    tell(user),
    write('¤¤¤ CATASTROPHIC ERROR ¤¤¤'),nl,
    write('*** Attempt to make a Variable Meta Production ***'),nl,

    told,

    abort. %% will cut the error message before printing

foundmeta(X):-
    assert(optiprod(X)).
  
%--

findvirtuals((X,Y)):-
    !,
    findvirtual(X),
    findvirtuals(Y).

findvirtuals(X):-
    findvirtual(X).
    

findvirtual(X):- 
    var(X),
    !,
    told, %% make message appear online
    nl,
    tell(user),
    write('%%% CATASTROPHIC ERROR %%%'),nl,
    write('*** Attempt to make a Variable Virtual Production ***'),nl,

    told,

    abort.  %% will cut the error message before printing

    
findvirtual(X):-
   (X=[_];
    X=[];
    X={_};
    X=w(_)),
    !.

findvirtual(A):- 
    remembervirtx(A), %% Must not get variable binding !!!!!
    functor(A,F,N),
    remember(virtf(F,N)). 

remembervirtx(A):-
    virtx(B),
    variant(A,B), %% utility.pl
    !;
    assert(virtx(A)).
    

plink:-plonk.

prite((X-->Y)):-
    writeq(X),write(' --> '),nl,
    prist(Y).

prist(Y):- var(Y),!,
    write(' *** Fatal error : variable right side ***'),nl,
    plink.

prist((X,Y)) :-
    !,
    write('    '),writeq(X),write(','),nl,
    prist(Y).

prist(X):-
    write('    '),writeq(X),write('.'),
    nl,nl.

% In a module system, runtime system is user.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





