%% FILE utility.pl
%% SYSTEM TUC
%% CREATED TA-921106
%% REVISED TA-001113

%% Utility Routines that are not built in 


this_year(YYYY):-
  datetime(YYYY,_B,_C,_D,_E,_F).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Some predicates are moved to library.pl
% to ease compatibility with prologs where these are built in
%
%  append/3 , member/2 , reverse/2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% dif(X,Y)  DELAY DIFFER  (built-in)
% freeze(X,P) DELAY P until X fixed
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

X := Y :- 
    set(X,Y).

X =: Y :-  
    value(X,Y). 


all(X):- 
    output(X),
    fail.

aggregate(min(+ N),L,L1):-
    firstlist1(N,L,L1).

aggregate(min(- N),L,X):-
    !,
    nthval(N,L,X).

aggregate(max(+ N),L,X):-        %% not stable, original order swapped
    !,
    reverse(L,L1),             %% Advanced Reverse
    firstlist1(N,L1,X). 


aggregate(max(- N),L,X):-      
    !,
    reverse(L,L1),             
    nthval(N,L1,X). 


aggregate(sum,L,X):-  
    sumcount(L,X,_).

aggregate(avg,L,X):-  
    sumcount(L,S,N),
    (N =:= 0 -> X is 0.0; 
              X is S/N).

aggregate(number,L,X):- 
    length(L,X).


% append([],A,A). 
% append([X|Y],U,[X|V]):-
%    append(Y,U,V).


appendfiles(A,B,C):-
    tell(C),
    see(A),
    proclaim,
    seen,
    see(B),
    proclaim,
    seen,
    told.

proclaim:-
    repeat,
    get0(C), 
    (C = -1  -> true, ! ; %  end_of_file
                put(C),fail).


%

sumcount([],0,0.0).
sumcount([X- _Y|R],S,N):-
    sumcount(R,S1,N1),
    N is N1 +1,
    S is S1 +X.


% % % % % % % % % % % % % % 

append_bl_atoms(A,B,C):-  %% append atoms with a blank
    name(A,AL),         
        name(' ',H),
        append(AL,H,ALH),
    name(B,BL),
    append(ALH,BL,CL),
    name(C,CL).

append_atoms(A,B,C):-  
    name(A,AL),
    name(B,BL),
    append(AL,BL,CL),
    name(C,CL).

compar(after,X,Y) :-
   number(X),number(Y), X > Y .

compar(before,X,Y):- 
   number(X),number(Y), X < Y .

% closit(F):- 
%    append_atoms(F,'.e',G),
%    close(G).

default(V,E):- 
    V=E,!;
    true.


%% avoid conflict with SWI (other parameter sequence)

delete1(X,[X|Y],Y).  
delete1(X,[U|V],[U|W]):-   
    delete1(X,V,W).

deleteall(X,Y,Z):- delall(X,Y,Z).

delall(_,[],[]):-!.
delall(X,[X|Y],Z):-!,delall(X,Y,Z).
delall(X,[U|Y],[U|Z]):-delall(X,Y,Z).

purge(_,[],[]):-!. 
purge(Dels,[X|Y],Z):- 
    member(X,Dels),
    !,
    purge(Dels,Y,Z).
purge(Dels,[U|Y],[U|Z]):-
    purge(Dels,Y,Z).


do(P):- \+ ( \+ P). 

doall(P):-  % P, then succeed 
    P,
    false;
    true.


do_count(F):- 
    F =: M,
    !,
    N is M+1,
    F := N.

do_count(F):- 
    F := 1 . 

ends_with(AS,A,S):- 
    atom(AS),
    atom(S),             %% Safety Check !!! 
    !,
    name(AS,ASL),
    name(S,SL),
    append(AL,SL,ASL),
    name(A,AL),
    !.

ends_with(AS,A,S):-  
    var(AS),
    !,
    atom(A),
    atom(S),
    name(A,AL),
    name(S,SL),
    append(AL,SL,ASL),
    name(AS,ASL),
    !.

last_character(AC,C):- 
    atom(AC),
    !,
    name(AC,ABS),
    append(_,[S],ABS),
    name(C,[S]),
    !.

equal(X,Y) :- atomic(X),atomic(Y),!,name(X,XN),name(Y,YN),XN==YN.
equal(X,Y) :- X==Y.

firstlist1(1,L,X1):- 
    !,
    L = [X|_Y],
    X = _Key - X1. %% Item may be reused, no key

firstlist1(N,K,X):-
    firstlist(N,K,X).

firstlist(N,[K-X|Y],[X-K|Z]):-
    N > 0,
    !,
    M is N-1,
    firstlist(M,Y,Z).

firstlist(_,_,[]).

%%% Convert an unflattened round list to a flat list 

flatlist(X,[X]):-
    \+match(X,(_,_)),
    !.
flatlist(X,Y):-  %% make a 
   flat1(X,Y).   %% flat square list


flat1((X,Y),Z):-  
    match(X,(U,V)), % X nonvar
    !,
    flat1((U,(V,Y)),Z).

flat1((X,Y),[X|Z]):-
    !,
    flat1(Y,Z).

flat1(X,[X]).



flatround((X,Y),Z):-  
    match(X,(U,V)), % X nonvar
    !,
    flatround((U,(V,Y)),Z).

flatround((X,Y),(X,Z)):-
    !,
    flatround(Y,Z).

flatround(X,X).



for(P,Q):-
  P,Q,
  false;true.

foralltest(P,Q):- \+ ( P, \+ Q). 

forget(X):- 
    retractall(X).

error(T,X):- 
    nl,
    write('*** '),write(T),write(' '),write(X),
    nl.

freshcopy(P,Q):-         
    copy_term(P,Q).  


ident_member(X,Z):-member(Y,Z),X==Y . 


%% ident_member(X,[Y|_]):- 
%%    X==Y ,!.  
%% ident_member(X,[_|Y]):-
%%     ident_member(X,Y).


identical(A,B):-   
    test((numbervars((A,B)),A=B)).


newconst(Y):- 
    do_count(const), % const := const+1
    const =: Y.




remove_duplicates1(X,Y):-   % preserves order of first occurrence
    rem_dups(X,[],Y).


rem_dups([],_,[]):-!.

rem_dups([X|Y],Keep,[X|Z]):-
     \+ member(X,Keep),
    !,
    rem_dups(Y,[X|Keep],Z).
rem_dups([_|Y],Keep,Z):-
    rem_dups(Y,Keep,Z).



lastmem([X],X):-!.  
lastmem([_|L],X) :- lastmem(L,X).     %% last ==> lastmem


match(X,Y):- % unidirected unification
    nonvar(X),
    !,
    X=Y.

% member(X,[X|_]).  
% member(X,[_|Y]):-
%     member(X,Y).

makestring(L,Str):- 
    makeacc(L,Str).

makeacc([],' '):-!.

makeacc([U],U):-!.

makeacc([U|V],S):-
    makacc(U,V,S).

makacc(Acc,[],Acc):-!.

makacc(Acc,[U|V],Result):-
    append_bl_atoms(Acc,U,AccU),
    makacc(AccU,V,Result).



minimum([A],A):-!. 
minimum([A,B|C],R):-
    minimum([B|C],R1),minval(A,R1,R).
minimum([],10000):-!.

minval(A,B,C):- 
( A < B -> 
  C is A
  ;
  C is B
).


maximum([A],A):-!. 
maximum([A,B|C],R):-
    maximum([B|C],R1),maxval(A,R1,R).
maximum([],-10000):-!.

maxval(A,B,C):- 
( A < B -> 

  C is B
  ;
  C is A
).




nthval(N,L,X):-
    nth(N,L,Y),
    Y = _K - X.


nth(N,Set,Nth) :-
	 nth_aux(N,Set,Nth,1).

nth_aux(N,[Nth|_],Nth,N).
nth_aux(N,[_|R],Nth,C) :-
	 CN is C+1,
	 nth_aux(N,R,Nth,CN).


number_of(X,Y,N):- 
    set_of(X,Y,Z),
    length(Z,N).

% round membership with recursion %% TA-001113

roundmember(X,Y):-occ(X,Y).

occ(_,B):-var(B),!.
occ(B,(B,_)).
occ(B,(_,D)):-occ(B,D).
occ(B,B):- \+ (B=(_,_)).
 
% round membership with recursion %% TA-001113
% i flatten + roundmember

roundrecmember(X,Y):-occrec(X,Y).

occrec(_,B):-var(B),!,fail. %% Serious
occrec(B,((C,D),E)):-!,
    occrec(B,(C,(D,E))).

occrec(B,(B,_)).
occrec(B,(_,D)):-occrec(B,D).
occrec(B,B):- \+ (B=(_,_)).



out(P):-write(P),tab(1).

output(P):-write(P),nl.


prettyprint(P):-
    numbervars(P),
    writeq(P),nl,
    false; % release bindings
    true.


doubt(A,B):-  
    language(english) -> out(A);
    language(norsk) -> out(B);
    out(A).



% Lexical Parse of a String

psl(S,L):-    
    tell('tore_amble.e'),
    write(S),
    nl,
    write('.'),nl,
    told,
    see('tore_amble.e'),
    read_in(L),
    seen.


remember(F):-F,!;assert(F).


remove_duplicates([],[]):-!.    
remove_duplicates([P],[P]):-!.  
remove_duplicates([X|Y],R):-
    member(U,Y),X==U,!,
    remove_duplicates(Y,R).
remove_duplicates([X|Y],[X|Z]):-
    remove_duplicates(Y,Z).


set(Counter,Value):- 
    retractall(value(Counter,_)),
    assert(value(Counter,Value)).


% Prologs setof is baroque %% 

set_of(X,Y,Z):-           %% 
    setof(X,Y^Y,Z),!;     %% Trick to avoid alternatives
    Z=[].                 %% What is wrong with empty sets ?

% starttime :-  
%    statistics(runtime,_).

% taketime :- 
%   statistics(runtime,[_,T]), 
%   out(T),output(ms).

union(X,Y,Z):- 
    set_of(U,(member(U,X);member(U,Y)),Z).


variant(X,Y):-   
    subsumes(X,Y),
    subsumes(Y,X).

subsumes(X,Y):-   % X at least as general
     test(subsum1(X,Y)).

subsum1(X,Y):-
     numbervars(Y),
     X=Y.

subcase(Y,X):-     
    subsumes(X,Y),  %% no variable is instantiated
    X=Y.            %% to a structure

test(X):- \+ ( \+ ( X)).

tryonce(P):-P,!.
tryonce(_). 

unsquare([P],P):-!.
unsquare([P,Q|R],(P,QR)):-
    unsquare([Q|R],QR).
unsquare([],true).  

pront(L):-
    nl,
    for(member(X,L),output(X)),
    nl.

writelist(Z):-
    for(member(X,Z),out(X)).

%%%%% THE END %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%  Test Lips rate according to Naive Reverse

naive:-
   write('N = '),read(N),
   makelistn(N,X),
   !,
   statistics(runtime,[A,_]),
   nreverse(X,_),
   statistics(runtime,[B,_]),
   C is B-A,
   write('Time '),write(C),write(' ms '),nl,
   LIPS is ((N*(N+1)/2)/ (C+0.000001))*1000 // 1 , 
   write('LIPS = '),write(LIPS),nl.
   
makelistn(0,[]).
makelistn(N,[a|X]):-
   M is N-1,
   makelistn(M,X).

nreverse([X|U],Z):-
    nreverse(U,V),
    append(V,[X],Z). % 1+ #V

nreverse([],[]).


replace(P,X,X,P):- 
    var(P),!.

replace(P,X,Y,Q):- % AD HOC
    freshcopy(P/X,Q/Y).

replacelist([],_,_,[]).
replacelist([A|C],A,B,[B|C]):-!.
replacelist([X|C],A,B,[X|D]):-
    replacelist(C,A,B,D).

    

snipfirst([_|L1],L1). 

sniplast(L,L1):-     
    append(L1,[_],L).


splitlast(ABC,AB,C):-append(AB,[C],ABC).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

debug(Prop):- 
    value(trace,4) ->
    (call(Prop) -> pling(Prop);true)

    ;
    true.

pling(I):-output(pling(I)). %%  Debug

